(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{526:function(e,t,a){e.exports=a.p+"assets/img/init-vue.c356e010.png"},527:function(e,t,a){e.exports=a.p+"assets/img/order.183cead2.png"},886:function(e,t,a){"use strict";a.r(t);var r=a(14),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"vue2-0-生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue2-0-生命周期"}},[e._v("#")]),e._v(" vue2.0 生命周期")]),e._v(" "),r("p",[e._v("Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。")]),e._v(" "),r("h3",{attrs:{id:"生命周期钩子函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子函数"}},[e._v("#")]),e._v(" 生命周期钩子函数")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("beforeCreate：组件刚被创建，组件属性计算之前")])]),e._v(" "),r("li",[r("p",[e._v("created：组件实例创建完成，属性已绑定， 但真实 dom 还没有生成，$el 还不可用,但是 data 和 method 可用")])]),e._v(" "),r("li",[r("p",[e._v("beforeMount：此时已经完成了模板的编译，在页面挂载开始之前被调用, 相关的 render 函数首次被调用")])]),e._v(" "),r("li",[r("p",[e._v("mounted：已经将编译好的模板，挂载到了页面指定的容器中显示,可操作 DOM（最早）")])]),e._v(" "),r("li",[r("p",[e._v("beforeUpdate：状态更新之前执行此函数，此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，此时还没有开始重新渲染 DOM 节点")])]),e._v(" "),r("li",[r("p",[e._v("updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！")])]),e._v(" "),r("li",[r("p",[e._v("beforeDestroy：实例销毁之前调用。在这一步，实例（data,methods,过滤器，指令）仍然完全可用。")]),e._v(" "),r("blockquote",[r("p",[e._v("使用场景：(日期在我点击查询的时候要存储,刷新就读内存,但是我点击其他页面再进来的时候,这个内存要清空)")])])]),e._v(" "),r("li",[r("p",[e._v("destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")])]),e._v(" "),r("li",[r("p",[e._v("activited keep-alive 专属，组件被激活时调用")])]),e._v(" "),r("li",[r("p",[e._v("deactivated keep-alive 专属，组件被销毁时调用")])])]),e._v(" "),r("h3",{attrs:{id:"在哪个钩子函数中调用接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在哪个钩子函数中调用接口"}},[e._v("#")]),e._v(" 在哪个钩子函数中调用接口")]),e._v(" "),r("p",[e._v("可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),e._v(" "),r("p",[e._v("能更快获取到服务端数据，减少页面  loading 时间；\nssr  不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；")]),e._v(" "),r("h3",{attrs:{id:"父子组件生命周期钩子函数执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#父子组件生命周期钩子函数执行顺序"}},[e._v("#")]),e._v(" 父子组件生命周期钩子函数执行顺序？")]),e._v(" "),r("p",[e._v("beforeCreate 不能访问到 methods、data、computed、watch 上的方法和数据")]),e._v(" "),r("p",[e._v("created 可以调用 methods 中定义的方法，修改 data 的数据，并且可触发响应式变化、computed 值重新计算，watch 到变更等")]),e._v(" "),r("blockquote",[r("p",[e._v("Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：")])]),e._v(" "),r("ul",[r("li",[r("p",[e._v("加载渲染过程")]),e._v(" "),r("blockquote",[r("p",[e._v("父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted")])])]),e._v(" "),r("li",[r("p",[e._v("子组件更新过程")]),e._v(" "),r("blockquote",[r("p",[e._v("父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated")])])]),e._v(" "),r("li",[r("p",[e._v("父组件更新过程")]),e._v(" "),r("blockquote",[r("p",[e._v("父 beforeUpdate -> 父 updated")])])]),e._v(" "),r("li",[r("p",[e._v("销毁过程")]),e._v(" "),r("blockquote",[r("p",[e._v("父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed")])])])]),e._v(" "),r("h3",{attrs:{id:"computed、watch-执行顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#computed、watch-执行顺序"}},[e._v("#")]),e._v(" computed、watch 执行顺序")]),e._v(" "),r("p",[e._v("在 created 之前就会 就会进行初始化 computed 和 watch")]),e._v(" "),r("p",[r("img",{attrs:{src:a(526),alt:"image"}})]),e._v(" "),r("p",[e._v("看以下执行顺序图可以得出：")]),e._v(" "),r("ol",[r("li",[e._v("初始化时父元素 向 子元素传递数据分两个阶段，")])]),e._v(" "),r("p",[e._v("(1) 一为父元素父 beforeMount 及之前的一个阶段，包括 data 中定义的赋值；")]),e._v(" "),r("p",[e._v("(2) 另一个阶段为，父元素 mounted 及其之后的阶段；在一个阶段中后面的赋值会替换前面的赋值；（如：父 created 覆盖父 data 中定义的），所以 watch 和 computed 会触发两次；")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("watch 有 immediate 属性： 首次绑定的时候，是否执行 handler，默认 false")])]),e._v(" "),r("p",[e._v("(1) 为 true 时，在子元素的 created 之前执行;")]),e._v(" "),r("p",[e._v("(2) 为 false 时 只有在父元素 mounted 之后值改变才会触发，否则是不会触发的；")]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[e._v("computed 执行值 computed 被引用处（数据变更时 watch 在 computed 之前执行），然后继续执行 computed 代码；computed 最早在 created 之后执行；")])]),e._v(" "),r("p",[r("img",{attrs:{src:a(527),alt:"image"}})]),e._v(" "),r("hr"),e._v(" "),r("p",[e._v("参考："),r("a",{attrs:{href:"https://www.cnblogs.com/voxov/p/15231725.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("父子组件生命周期、watch、computed 的执行顺序"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);