(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{617:function(t,e,v){"use strict";v.r(e);var a=v(24),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("回流必将引起重绘，重绘不一定会引起回流。")]),t._v(" "),v("p",[t._v("绝对定位也会发生回流，但只是脱离文档流的哪个部分发生回流与重绘。")]),t._v(" "),v("h2",{attrs:{id:"回流-reflow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow"}},[t._v("#")]),t._v(" 回流 (Reflow)")]),t._v(" "),v("p",[t._v("当我们对 DOM 的修改引发了 DOM 几何尺寸的变化浏览器重新渲染部分或全部文档的过程称为回流。")]),t._v(" "),v("p",[t._v("当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。")]),t._v(" "),v("p",[t._v("会导致回流的操作：")]),t._v(" "),v("ul",[v("li",[t._v("页面首次渲染")]),t._v(" "),v("li",[t._v("浏览器窗口大小发生改变")]),t._v(" "),v("li",[t._v("元素尺寸或位置发生改变")]),t._v(" "),v("li",[t._v("元素内容变化（文字数量或图片大小等等）")]),t._v(" "),v("li",[t._v("元素字体大小变化")]),t._v(" "),v("li",[t._v("添加或者删除可见的 DOM 元素")]),t._v(" "),v("li",[t._v("激活 CSS 伪类（例如：:hover）")]),t._v(" "),v("li",[t._v("查询某些属性或调用某些方法")])]),t._v(" "),v("p",[t._v("一些常用且会导致回流的属性和方法：")]),t._v(" "),v("ul",[v("li",[t._v("clientWidth、clientHeight、clientTop、clientLeft")]),t._v(" "),v("li",[t._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),t._v(" "),v("li",[t._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),t._v(" "),v("li",[t._v("scrollIntoView()、scrollIntoViewIfNeeded()")]),t._v(" "),v("li",[t._v("getComputedStyle()")]),t._v(" "),v("li",[t._v("getBoundingClientRect()")]),t._v(" "),v("li",[t._v("scrollTo()")])]),t._v(" "),v("h2",{attrs:{id:"重绘-repaint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[t._v("#")]),t._v(" 重绘 (Repaint)")]),t._v(" "),v("p",[t._v("当我们对 DOM 的修改导致了样式的变化（例如：color、background-color、visibility 等）、却并未影响其几何属性，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。")]),t._v(" "),v("h2",{attrs:{id:"性能影响"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#性能影响"}},[t._v("#")]),t._v(" 性能影响")]),t._v(" "),v("p",[t._v("回流比重绘的代价要更高。\n有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。\n现代浏览器会对频繁的回流或重绘操作进行优化：\n浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。\n当你访问以下属性或方法时，浏览器会立刻清空队列：")]),t._v(" "),v("ul",[v("li",[t._v("clientWidth、clientHeight、clientTop、clientLeft")]),t._v(" "),v("li",[t._v("offsetWidth、offsetHeight、offsetTop、offsetLeft")]),t._v(" "),v("li",[t._v("scrollWidth、scrollHeight、scrollTop、scrollLeft")]),t._v(" "),v("li",[t._v("width、height")]),t._v(" "),v("li",[t._v("getComputedStyle()")]),t._v(" "),v("li",[t._v("getBoundingClientRect()")])]),t._v(" "),v("p",[t._v("因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。")]),t._v(" "),v("h2",{attrs:{id:"避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#避免"}},[t._v("#")]),t._v(" 避免")]),t._v(" "),v("h3",{attrs:{id:"css-避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#css-避免"}},[t._v("#")]),t._v(" CSS 避免")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("避免使用 table 布局。tables 中某个元素一旦触发 reflow 就会导致 table 里所有的其它元素 reflow。在适合用 table 的场合，可以设置 table-layout 为 auto 或 fixed，这样可以让 table 一行一行的渲染，这种做法也是为了限制 reflow 的影响范围")])]),t._v(" "),v("li",[v("p",[t._v("尽可能在 DOM 树的最末端改变 class。")])]),t._v(" "),v("li",[v("p",[t._v("避免设置多层内联样式。")])]),t._v(" "),v("li",[v("p",[t._v("将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。")])]),t._v(" "),v("li",[v("p",[t._v("避免使用 CSS 表达式（例如：calc()）。")])])]),t._v(" "),v("h3",{attrs:{id:"javascript-避免"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript-避免"}},[t._v("#")]),t._v(" JavaScript 避免")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。")])]),t._v(" "),v("li",[v("p",[t._v("避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。")])]),t._v(" "),v("li",[v("p",[t._v("也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。这样只在隐藏和显示时触发 2 次重排。但是这可能导致浏览器的闪烁。")])]),t._v(" "),v("li",[v("p",[t._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。")])]),t._v(" "),v("li",[v("p",[t._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。")])])]),t._v(" "),v("h2",{attrs:{id:"问题汇总"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题汇总"}},[t._v("#")]),t._v(" 问题汇总")]),t._v(" "),v("h3",{attrs:{id:"transform-会造成回流吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#transform-会造成回流吗"}},[t._v("#")]),t._v(" transform 会造成回流吗")]),t._v(" "),v("p",[t._v("translate / transform 确实不影响真实占位不会重排")]),t._v(" "),v("p",[t._v("CSS 的最终表现分为以下四步：Recalculate Style -> Layout -> Paint Setup and Paint -> Composite Layers")]),t._v(" "),v("p",[t._v("按照中文的意思大致是 查找并计算样式 -> 排布 -> 绘制 -> 组合层")]),t._v(" "),v("p",[t._v("由于 transform 是位于 Composite Layers 层，而 width、left、margin 等则是位于 Layout 层，在 Layout 层发生的改变必定导致 Paint Setup and Paint -> Composite Layers，所以相对而言使用 transform 实现的动画效果肯定比 left 这些更加流畅。")]),t._v(" "),v("h3",{attrs:{id:"translate-会引起重排吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#translate-会引起重排吗"}},[t._v("#")]),t._v(" translate 会引起重排吗?")]),t._v(" "),v("p",[v("strong",[v("em",[t._v("不会")])])]),t._v(" "),v("p",[t._v("translate 样式变化会移交 GPU 处理。")]),t._v(" "),v("p",[t._v("因为 GPU 进程会为其开启一个新的复合图层，不会影响默认复合图层（就是普通文档流），所以并不会影响周边的 DOM 结构，而属性的改变也会交给 GPU 处理，不会进行重排。")]),t._v(" "),v("p",[t._v("使 GPU 进程开启一个新的复合图层的方式还有 3D 动画，过渡动画，以及 opacity 属性，还有一些标签，这些都可以创建新的复合图层。这些方式叫做硬件加速方式。")]),t._v(" "),v("p",[t._v("降低重排的方式：要么减少次数，要么降低影响范围，创建新的复合图层就是第二种优化方式。")]),t._v(" "),v("p",[t._v("如果你要使用硬件加速方式降低重排的影响，请不要过度使用，创建新的复合图层是有额外消耗的，比如更多的内存消耗，并且在使用硬件加速方式时，配合 z-index 一起使用，尽可能使新的复合图层的元素层级等级最高。")]),t._v(" "),v("h3",{attrs:{id:"查询-css-属性的时候会触发重排么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查询-css-属性的时候会触发重排么"}},[t._v("#")]),t._v(" 查询 css 属性的时候会触发重排么 ？")]),t._v(" "),v("p",[t._v("会")]),t._v(" "),v("p",[t._v("getComputedStyle 需要返回最新的布局信息，因此浏览器不得不执行渲染队列中的“待处理变化”并触发重排，以返回正确的值。因此，修改样式的过程中，最好避免使用以上的属性或者是方法。")])])}),[],!1,null,null,null);e.default=_.exports}}]);