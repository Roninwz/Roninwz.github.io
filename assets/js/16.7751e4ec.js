(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{539:function(t,a,e){t.exports=e.p+"assets/img/init-vue.c356e010.png"},540:function(t,a,e){t.exports=e.p+"assets/img/order.183cead2.png"},933:function(t,a,e){"use strict";e.r(a);var c=e(14),r=Object(c.a)({},(function(){var t=this,a=t.$createElement,c=t._self._c||a;return c("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[c("h2",{attrs:{id:"watch-源码分析"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#watch-源码分析"}},[t._v("#")]),t._v(" watch 源码分析")]),t._v(" "),c("ol",[c("li",[t._v("判断 watch 写法（字符串，数组，函数）")])]),t._v(" "),c("p",[t._v("调用 createWatcher ，从用户合起来传入的对象中把回调函数 cb 和参数 options 剥离出来，调用$watch 方法")]),t._v(" "),c("h3",{attrs:{id:"watch-中的-deep-true-是如何实现的"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#watch-中的-deep-true-是如何实现的"}},[t._v("#")]),t._v(" Watch 中的 deep:true 是如何实现的")]),t._v(" "),c("p",[t._v("当用户指定了 watch 中的 deep 属性为 true 时\n监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器\n如果当前监控的值是数组类型。会对对象中的每一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也会通知数据更新")]),t._v(" "),c("h2",{attrs:{id:"watch-问题"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#watch-问题"}},[t._v("#")]),t._v(" watch 问题")]),t._v(" "),c("h3",{attrs:{id:"watch-与-computed-的区别"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#watch-与-computed-的区别"}},[t._v("#")]),t._v(" watch 与 computed 的区别")]),t._v(" "),c("ol",[c("li",[t._v("缓存支持")])]),t._v(" "),c("p",[t._v("watch 不支持缓存，数据变，直接会触发相应的操作；")]),t._v(" "),c("p",[t._v("computed 支持缓存，只有依赖数据发生改变，才会重新进行计算")]),t._v(" "),c("ol",{attrs:{start:"2"}},[c("li",[t._v("异步支持")])]),t._v(" "),c("p",[t._v("watch 支持异步；")]),t._v(" "),c("p",[t._v("computed 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化")]),t._v(" "),c("ol",{attrs:{start:"3"}},[c("li",[t._v("使用场景")])]),t._v(" "),c("p",[t._v("watch 当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。")]),t._v(" "),c("p",[t._v("computed 当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。")]),t._v(" "),c("h3",{attrs:{id:"computed、watch-执行顺序"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#computed、watch-执行顺序"}},[t._v("#")]),t._v(" computed、watch 执行顺序")]),t._v(" "),c("p",[t._v("在 created 之前就会 就会进行初始化 computed 和 watch")]),t._v(" "),c("p",[c("img",{attrs:{src:e(539),alt:"image"}})]),t._v(" "),c("p",[t._v("看以下执行顺序图可以得出：")]),t._v(" "),c("ol",[c("li",[t._v("初始化时父元素 向 子元素传递数据分两个阶段，")])]),t._v(" "),c("p",[t._v("(1) 一为父元素父 beforeMount 及之前的一个阶段，包括 data 中定义的赋值；")]),t._v(" "),c("p",[t._v("(2) 另一个阶段为，父元素 mounted 及其之后的阶段；在一个阶段中后面的赋值会替换前面的赋值；（如：父 created 覆盖父 data 中定义的），所以 watch 和 computed 会触发两次；")]),t._v(" "),c("ol",{attrs:{start:"2"}},[c("li",[t._v("watch 有 immediate 属性： 首次绑定的时候，是否执行 handler，默认 false")])]),t._v(" "),c("p",[t._v("(1) 为 true 时，在子元素的 created 之前执行;")]),t._v(" "),c("p",[t._v("(2) 为 false 时 只有在父元素 mounted 之后值改变才会触发，否则是不会触发的；")]),t._v(" "),c("ol",{attrs:{start:"3"}},[c("li",[t._v("computed 执行值 computed 被引用处（数据变更时 watch 在 computed 之前执行），然后继续执行 computed 代码；computed 最早在 created 之后执行；")])]),t._v(" "),c("p",[c("img",{attrs:{src:e(540),alt:"image"}})]),t._v(" "),c("hr"),t._v(" "),c("p",[t._v("参考："),c("a",{attrs:{href:"https://www.cnblogs.com/voxov/p/15231725.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("父子组件生命周期、watch、computed 的执行顺序"),c("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);