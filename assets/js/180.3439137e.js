(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{640:function(s,t,_){"use strict";_.r(t);var v=_(24),a=Object(v.a)({},(function(){var s=this,t=s.$createElement,_=s._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[_("h2",{attrs:{id:"白屏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#白屏"}},[s._v("#")]),s._v(" 白屏")]),s._v(" "),_("p",[s._v("前端优化-如何计算白屏和首屏时间 "),_("a",{attrs:{href:"https://www.cnblogs.com/longm/p/7382163.html",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://www.cnblogs.com/longm/p/7382163.html"),_("OutboundLink")],1)]),s._v(" "),_("h3",{attrs:{id:"白屏原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#白屏原因"}},[s._v("#")]),s._v(" 白屏原因")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("网络原因：页面渲染被阻塞，在弱网络下(2G 网路或者 GPRS 网络) ,网络延迟，JS 加载延迟 ,会阻塞页面")])]),s._v(" "),_("li",[_("p",[s._v("前端代码错误：客户端存在 bug，js 报错或者语法不兼容")])])]),s._v(" "),_("h3",{attrs:{id:"白屏解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#白屏解决方案"}},[s._v("#")]),s._v(" 白屏解决方案")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("骨架屏")])]),s._v(" "),_("li",[_("p",[s._v("预渲染")])]),s._v(" "),_("li",[_("p",[s._v("服务器端渲染")])])]),s._v(" "),_("p",[s._v("注意：网络原因要给用户反馈")]),s._v(" "),_("h2",{attrs:{id:"浏览器加载、解析、渲染过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器加载、解析、渲染过程"}},[s._v("#")]),s._v(" 浏览器加载、解析、渲染过程")]),s._v(" "),_("ol",[_("li",[s._v("加载：")])]),s._v(" "),_("p",[s._v("了解浏览器如何进行加载，可以在引用外部样式文件，外部 js 时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。")]),s._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[s._v("解析：")])]),s._v(" "),_("p",[s._v("了解浏览器如何进行解析，我们可以在构建 DOM 结构，组织 css 选择器时，选择最优的写法，提高浏览器的解析速率。")]),s._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[s._v("渲染：")])]),s._v(" "),_("p",[s._v('了解浏览人如何进行渲染，我们可以在设置元素属性，编写 js 文件时，可以减少"重排""重绘"的消耗。')]),s._v(" "),_("p",[s._v("总结：这三个过程在事件进行的时候不是完全独立，会有交叉。会一边加载，一遍解析，一遍渲染的工作想象。")]),s._v(" "),_("h3",{attrs:{id:"_1-输入-url-到页面展示的全过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-输入-url-到页面展示的全过程"}},[s._v("#")]),s._v(" 1. 输入 url 到页面展示的全过程")]),s._v(" "),_("ol",[_("li",[s._v("解析 URL")])]),s._v(" "),_("p",[s._v("当在浏览器中输入 URL 后，浏览器首先对拿到的 URL 进行识别，抽取出域名字段。")]),s._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[s._v("DNS 解析（域名解析）")])]),s._v(" "),_("p",[s._v("通过 DNS 解析，获取到域名对应的 IP")]),s._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[s._v("TCP 连接")])]),s._v(" "),_("h3",{attrs:{id:"_2-页面加载-解析过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-页面加载-解析过程"}},[s._v("#")]),s._v(" 2. 页面加载,解析过程")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("解析 HTML 结构。")])]),s._v(" "),_("li",[_("p",[s._v("加载外部脚本和样式表文件。")])]),s._v(" "),_("li",[_("p",[s._v("解析并执行脚本代码。//js 之类的")])]),s._v(" "),_("li",[_("p",[s._v("DOM 树构建完成。(DOMContentLoaded 事件触发,仅当 DOM 加载完成，不包括样式表，图片，flash)")])]),s._v(" "),_("li",[_("p",[s._v("加载图片等外部文件。")])]),s._v(" "),_("li",[_("p",[s._v("页面加载完毕。(onload 事件触发：页面上所有的 DOM，样式表，脚本，图片，flash 都已经加载完成了。)")])])]),s._v(" "),_("h3",{attrs:{id:"_3-页面渲染过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-页面渲染过程"}},[s._v("#")]),s._v(" 3. 页面渲染过程")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("解析 HTML 结构，构建 DOM 树。过程：字节->字符->语义块->节点->DOM （Bytes → characters → tokens → nodes → object model）.")])]),s._v(" "),_("li",[_("p",[s._v("解析 CSS ，构建 CSSOM 树。过程：字节->字符->语义块->节点->DOM")])])]),s._v(" "),_("blockquote",[_("p",[s._v("解析 CSS 样式，解析的顺序是浏览器的样式 -> 用户自定义的样式 -> 页面的 link 标签等引进来的样式 -> 写在 style 标签里面的内联样式")])]),s._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[s._v("合并 DOM 树和 CSSOM 树构建渲染树")])]),s._v(" "),_("p",[s._v("(1)、过滤掉不可见节点(脚本标记、元标记)")]),s._v(" "),_("p",[s._v("(2)、过滤掉样式隐藏的节点（display:none）")]),s._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[_("p",[s._v("布局 Render 树：根据渲染树来布局，计算节点的几何信息（layout）")])]),s._v(" "),_("li",[_("p",[s._v("绘制 Render 树：将各个节点绘制在屏幕上（paint）")])])]),s._v(" "),_("h3",{attrs:{id:"css-加载、解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css-加载、解析"}},[s._v("#")]),s._v(" css 加载、解析")]),s._v(" "),_("p",[s._v("CSS 的解析是从右往左逆向解析的(从 DOM 树的下－上解析比上－下解析效率高)，嵌套标签越多，解析越慢。")]),s._v(" "),_("p",[s._v("css 加载会阻塞 DOM 树的渲染")]),s._v(" "),_("p",[s._v("css 加载会阻塞后面 js 语句的执行")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("CSS 的加载和解析不会阻塞 HTML 的解析（即：不会阻塞 Dom 树的生成）")])]),s._v(" "),_("li",[_("p",[s._v("CSS 的加载和解析会阻塞 渲染树 RenderTree 的生成，也会阻塞界面的渲染！")])])]),s._v(" "),_("p",[s._v("渲染树 RenderTree 是根据 Dom 和 CSSOM 生成的，所以，在 CSSOM 还未完成之前， 是无法生成渲染树的，之后的流程更是无法进行；所以 CSS 的加载和解析会阻塞 生成渲染树 RenderTre 及其之后的流程；")]),s._v(" "),_("h3",{attrs:{id:"js-加载、解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js-加载、解析"}},[s._v("#")]),s._v(" js 加载、解析")]),s._v(" "),_("ol",[_("li",[s._v("没有设置 defer 或 async 的 js 的加载会阻塞 HTML 的解析（即：会阻塞 Dom 树的生成），设置了 defer 或 async 的 js 不阻塞 HTML 的解析；")])]),s._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[s._v("JS 的执行，都会阻塞 HTML 的解析")])]),s._v(" "),_("h3",{attrs:{id:"defer-和-async-属性的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#defer-和-async-属性的区别"}},[s._v("#")]),s._v(" defer 和 async 属性的区别")]),s._v(" "),_("p",[s._v("script 标签存在两个属性，defer 和 async")]),s._v(" "),_("ol",[_("li",[s._v("async 属性")])]),s._v(" "),_("p",[s._v("顺序：加载优先顺序，脚本在文档中的顺序不重要，先加载完成先执行")]),s._v(" "),_("p",[s._v("表示后续文档的加载和渲染与 js 脚本的加载和执行是并行进行的，即异步执行")]),s._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[s._v("defer 属性")])]),s._v(" "),_("p",[s._v("顺序：文档顺序，")]),s._v(" "),_("p",[s._v("加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded 事件触发执行之前")]),s._v(" "),_("h3",{attrs:{id:"媒体资源加载、解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#媒体资源加载、解析"}},[s._v("#")]),s._v(" 媒体资源加载、解析")]),s._v(" "),_("ol",[_("li",[_("p",[s._v("媒体资源(如:图片音视频等)的加载不会阻塞 HTML 的解析！")])]),s._v(" "),_("li",[_("p",[s._v("媒体资源是并行加载的！")])])]),s._v(" "),_("p",[s._v("因为媒体资源的加载不会阻塞 HTML 的解析，那么，浏览器加载第一个媒体资源时，HTML 还可以继续往下解析，当解析到其它媒体资源的标签时，浏览器还可以继续加载相应的媒体资源，所以媒体资源是并行加载的！")]),s._v(" "),_("h2",{attrs:{id:"问题汇总"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#问题汇总"}},[s._v("#")]),s._v(" 问题汇总")]),s._v(" "),_("h3",{attrs:{id:"javascript-为什么会阻塞渲染-css-会不会阻塞渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript-为什么会阻塞渲染-css-会不会阻塞渲染"}},[s._v("#")]),s._v(" JavaScript 为什么会阻塞渲染？css 会不会阻塞渲染")]),s._v(" "),_("p",[s._v("js 在加载之前，浏览器不能识别 js 具体的操作，js 是可以操作 DOM 的，如果在修改元素属性的同时渲染界面，会出现不可预期的结果，导致渲染混乱，因此浏览器设置了 GUI 渲染现成和 js 线程互斥，在 js 执行的时候，GUI 线程会被挂起，等空闲的时候再执行。")]),s._v(" "),_("p",[s._v("dom 解析和 css 解析是两个并行的线程，所以 css 加载不会阻塞 dom 的解析")]),s._v(" "),_("p",[s._v("但是 render tree 是依赖 dom tree 和 cssom tree 的，因此，css 的加载会阻塞 dom 的渲染")])])}),[],!1,null,null,null);t.default=a.exports}}]);