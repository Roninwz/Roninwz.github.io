(window.webpackJsonp=window.webpackJsonp||[]).push([[197],{660:function(t,a,n){"use strict";n.r(a);var o=n(24),r=Object(o.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"微前端"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#微前端"}},[t._v("#")]),t._v(" 微前端")]),t._v(" "),n("h3",{attrs:{id:"qiankun-原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#qiankun-原理"}},[t._v("#")]),t._v(" qiankun 原理")]),t._v(" "),n("p",[t._v("qiankun 框架的编写基于两个十分重要框架，一个是 single-spa，另外一个是 import-html-entry")]),t._v(" "),n("h3",{attrs:{id:"沙箱隔离"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#沙箱隔离"}},[t._v("#")]),t._v(" 沙箱隔离")]),t._v(" "),n("p",[t._v("qiankun 做沙箱隔离主要分为三种：")]),t._v(" "),n("ol",[n("li",[t._v("legacySandBox")])]),t._v(" "),n("p",[t._v("legacySandBox 的本质上还是操作 window 对象")]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("proxySandBox")])]),t._v(" "),n("p",[t._v("proxySandBox 为了支持多实例的场景，proxySandBox 不会直接操作 window 对象。并且为了避免子应用操作或者修改主应用上诸如 window、document、location 这些重要的属性，会遍历这些属性到子应用 window 副本（fakeWindow）上")]),t._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[t._v("snapshotSandBox。")])]),t._v(" "),n("p",[t._v("snapshotSandBox 的原理就是在子应用激活 / 卸载时分别去通过快照的形式记录/还原状态来实现沙箱的。")]),t._v(" "),n("p",[t._v("总结：其中 legacySandBox、proxySandBox 是基于 Proxy API 来实现的，在不支持 Proxy API 的低版本浏览器中，会降级为 snapshotSandBox。在现版本中，legacySandBox 仅用于 singular 单实例模式，而多实例模式会使用 proxySandBox。")]),t._v(" "),n("h3",{attrs:{id:"微前端问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#微前端问题"}},[t._v("#")]),t._v(" 微前端问题")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("qiankun 是如何完善 single-spa 中留下的巨大缺口-————加载函数")])]),t._v(" "),n("li",[n("p",[t._v("qiankun 通过什么策略去加载子应用资源————window.fetch。")])]),t._v(" "),n("li",[n("p",[t._v("qiankun 如何隔离子应用的 js 的全局环境————通过沙箱。")])]),t._v(" "),n("li",[n("p",[t._v("沙箱的隔离原理是什么")])])]),t._v(" "),n("p",[t._v("在支持 proxy 中有一个代理对象，子应用优先访问到了代理对象，如果代理对象没有的值再从 window 中获取。如果不支持 proxy，那么通过快照，缓存，复原的形式解决污染问题。")]),t._v(" "),n("ol",{attrs:{start:"5"}},[n("li",[t._v("qiankun 如何隔离 css 环境")])]),t._v(" "),n("p",[t._v("shadowDOM 隔离；加上选择器隔离。")]),t._v(" "),n("ol",{attrs:{start:"6"}},[n("li",[t._v("qiankun 如何获得子应用生命周期函数")])]),t._v(" "),n("p",[t._v("export 存储在对象中，然后解构出来。")]),t._v(" "),n("ol",{attrs:{start:"7"}},[n("li",[t._v("qiankun 如何该改变子应用的 window 环境")])]),t._v(" "),n("p",[t._v("通过立即执行函数，传入 window.proxy 为参数，改变 window 环境。")]),t._v(" "),n("blockquote",[n("p",[t._v("参考：")])]),t._v(" "),n("p",[t._v("微前端 qiankun 原理学习 "),n("a",{attrs:{href:"https://www.cnblogs.com/synY/p/13969785.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/synY/p/13969785.html"),n("OutboundLink")],1)]),t._v(" "),n("p",[t._v("万字长文+图文并茂+全面解析微前端框架 qiankun 源码 - qiankun 篇 "),n("a",{attrs:{href:"https://segmentfault.com/a/1190000022275991",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000022275991"),n("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);