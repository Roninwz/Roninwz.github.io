(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{665:function(a,l,t){"use strict";t.r(l);var s=t(24),v=Object(s.a)({},(function(){var a=this,l=a.$createElement,t=a._self._c||l;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"babel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[a._v("#")]),a._v(" babel")]),a._v(" "),t("p",[a._v("参考地址-babel 插件手册："),t("a",{attrs:{href:"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md"),t("OutboundLink")],1)]),a._v(" "),t("p",[a._v("babel 是一个转译器。")]),a._v(" "),t("p",[a._v("把同种的高版本规则翻译成低版本规则，输出的是另一种更低级的语言代码。")]),a._v(" "),t("p",[a._v("Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。")]),a._v(" "),t("h3",{attrs:{id:"babel-编译过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel-编译过程"}},[a._v("#")]),a._v(" babel 编译过程")]),a._v(" "),t("ol",[t("li",[a._v("解析(PARSE)：将代码字符串解析成抽象语法树。")])]),a._v(" "),t("p",[a._v("解析步骤接收代码并输出 AST。 这个步骤分为两个阶段：词法分析（Lexical Analysis） 和 语法分析（Syntactic Analysis）。")]),a._v(" "),t("p",[a._v("词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。")]),a._v(" "),t("p",[a._v("语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的表述结构，这样更易于后续的操作。")]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("转换(TRANSFORM)：对抽象语法树进行转换操作。")])]),a._v(" "),t("p",[a._v("转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分")]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("生成(GENERATE): 根据变换后的抽象语法树再生成代码字符串。")])]),a._v(" "),t("p",[a._v("代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。.")]),a._v(" "),t("p",[a._v("代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。")]),a._v(" "),t("h3",{attrs:{id:"babel-两种插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel-两种插件"}},[a._v("#")]),a._v(" babel 两种插件")]),a._v(" "),t("ol",[t("li",[a._v("语法插件")])]),a._v(" "),t("p",[a._v("语法插件作用于 "),t("code",[a._v("@babel/parser")]),a._v("，负责将代码解析为抽象语法树（AST）")]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("转换插件")])]),a._v(" "),t("p",[a._v("转换插件作用于 "),t("code",[a._v("@babel/core")]),a._v("，负责转换 AST 的形态（官方的转换插件以 babel-plugin-transform（正式）或 babel-plugin-proposal（提案）开头）")]),a._v(" "),t("h3",{attrs:{id:"预设的插件集-presets"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#预设的插件集-presets"}},[a._v("#")]),a._v(" 预设的插件集(presets)")]),a._v(" "),t("p",[a._v("预设的插件集，以 JS 标准为例，babel 提供了如下的一些 preset:")]),a._v(" "),t("p",[a._v("es2015")]),a._v(" "),t("p",[a._v("es2016")]),a._v(" "),t("p",[a._v("es2017")]),a._v(" "),t("p",[a._v("env: 代指最新的标准，包括了 latest 和 es20xx 各年份")]),a._v(" "),t("p",[a._v("stage-0 到 stage-4 的标准成形之前的各个阶段，都是实验版的 preset，建议不使用。")]),a._v(" "),t("h3",{attrs:{id:"plugins"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#plugins"}},[a._v("#")]),a._v(" plugins")]),a._v(" "),t("p",[a._v("应用于 babel 转译的 transforming 阶段，如果该阶段不使用插件，babel 会原样输出代码。")]),a._v(" "),t("p",[a._v("主要关注 transfoming 阶段使用的插件，因为 transform 插件会自动使用对应的词法插件，所以 parsing 阶段的插件不需要再配置。")]),a._v(" "),t("h3",{attrs:{id:"polyfill"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#polyfill"}},[a._v("#")]),a._v(" polyfill")]),a._v(" "),t("p",[a._v("polyfill 是一段代码(或者插件)，提供了那些开发者们希望浏览器原生提供支持的功能。程序库先检查浏览器是否支持某个 API，如果不支持则加载对应的 polyfill。主要特征：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("是一个浏览器 API 的 Shim;")])]),a._v(" "),t("li",[t("p",[a._v("与浏览器有关;")])]),a._v(" "),t("li",[t("p",[a._v("没有提供新的 API，只是在 API 中实现缺少的功能;")])]),a._v(" "),t("li",[t("p",[a._v("以只需要引入 polyfill ，它会静静地工作;")])])]),a._v(" "),t("h4",{attrs:{id:"babel-polyfill"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#babel-polyfill"}},[a._v("#")]),a._v(" babel-polyfill")]),a._v(" "),t("p",[a._v("针对 es2015+ 环境的 shim")]),a._v(" "),t("p",[a._v("实现：把 core-js 和 regenerator runtime 包装")]),a._v(" "),t("p",[a._v("使用 babel-polyfill 会把 es2015+ 环境整体引入到代码环境中，代码可以直接使用新标准所引入的新原生对象，新 API 等，一般来说单独的应用和页面都可以这样使用")]),a._v(" "),t("h3",{attrs:{id:"shim"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shim"}},[a._v("#")]),a._v(" Shim")]),a._v(" "),t("p",[a._v("Shim 指的是在一个旧的环境中模拟出一个新 API ，而且仅靠旧环境中已有的手段实现，以便所有的浏览器具有相同的行为。主要特征：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("该 API 存在于现代浏览器中;")])]),a._v(" "),t("li",[t("p",[a._v("浏览器有各自的 API 或 可通过别的 API 实现;")])]),a._v(" "),t("li",[t("p",[a._v("API 的所有方法都被重新实现；")])]),a._v(" "),t("li",[t("p",[a._v("拦截 API 调用，并提供自己的实现；")])]),a._v(" "),t("li",[t("p",[a._v("是一个优雅降级。")])])]),a._v(" "),t("p",[a._v("shim 的概念要比 polyfill 更大一些，可以将 polyfill 理解为专门兼容浏览器 API 的 shim 。简单的说，如果浏览器 X 支持标准规定的功能，那么 polyfill 可以让浏览器 Y 的行为与浏览器 X 一样。")]),a._v(" "),t("h3",{attrs:{id:"shim-和-polyfill-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shim-和-polyfill-有什么区别"}},[a._v("#")]),a._v(" shim 和 polyfill 有什么区别")]),a._v(" "),t("p",[a._v("一个 shim 是一个库,它将一个新的 API 引入到一个旧的环境中,而且仅靠旧环境中已有的手段实现")]),a._v(" "),t("p",[a._v("一个 polyfill 就是一个用在浏览器 API 上的 shim.我们通常的做法是先检查当前浏览器是否支持某个 API, 如果不支持的话就加载对应的 polyfill.然后新旧浏览器就都可以使用这个 API 了.")])])}),[],!1,null,null,null);l.default=v.exports}}]);