(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{756:function(t,r,e){"use strict";e.r(r);var a=e(14),_=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"虚拟列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟列表"}},[t._v("#")]),t._v(" 虚拟列表")]),t._v(" "),e("p",[t._v("虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。")]),t._v(" "),e("h3",{attrs:{id:"为什么需要虚拟列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要虚拟列表"}},[t._v("#")]),t._v(" 为什么需要虚拟列表")]),t._v(" "),e("p",[t._v("虚拟列表是对长列表的一种优化方案。在前端开发中，会碰到一些不能使用分页方式来加载列表数据的业务形态，我们称这种列表叫做长列表。比如，在一些外汇交易系统中，前端会准实时的展示用户的持仓情况(收益、亏损、手数等)，此时对于用户的持仓列表一般是不能分页的。")]),t._v(" "),e("h3",{attrs:{id:"相关概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#相关概念"}},[t._v("#")]),t._v(" 相关概念")]),t._v(" "),e("p",[t._v("滚动容器元素：一般情况下，滚动容器元素是 window 对象。然而，我们可以通过布局的方式，在某个页面中任意指定一个或者多个滚动容器元素。只要某个元素能在内部产生横向或者纵向的滚动，那这个元素就是滚动容器元素考虑每个列表项只是渲染一些纯文本。在本文中，只讨论元素的纵向滚动。")]),t._v(" "),e("p",[t._v("可滚动区域：滚动容器元素的内部内容区域。假设有 100 条数据，每个列表项的高度是 50，那么可滚动的区域的高度就是 100 * 50。可滚动区域当前的具体高度值一般可以通过(滚动容器)元素的 scrollHeight 属性获取。用户可以通过滚动来改变列表在可视区域的显示部分。")]),t._v(" "),e("p",[t._v("可视区域：滚动容器元素的视觉可见区域。如果容器元素是 window 对象，可视区域就是浏览器的视口大小(即视觉视口)；如果容器元素是某个 div 元素，其高度是 300，右侧有纵向滚动条可以滚动，那么视觉可见的区域就是可视区域。")]),t._v(" "),e("p",[t._v("实现虚拟列表就是在处理用户滚动时，要改变列表在可视区域的渲染部分，其具体步骤如下：")]),t._v(" "),e("ul",[e("li",[t._v("计算当前可见区域起始数据的 startIndex")]),t._v(" "),e("li",[t._v("计算当前可见区域结束数据的 endIndex")]),t._v(" "),e("li",[t._v("计算当前可见区域的数据，并渲染到页面中")]),t._v(" "),e("li",[t._v("计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset，并设置到列表上")]),t._v(" "),e("li",[t._v("计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到列表上")])]),t._v(" "),e("h3",{attrs:{id:"定高虚拟列表实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定高虚拟列表实现"}},[t._v("#")]),t._v(" 定高虚拟列表实现")]),t._v(" "),e("p",[t._v("因此，实现「虚拟列表」可以简单理解为就是在列表发生滚动时，改变「可视区域」内的渲染元素。大概的文字逻辑步骤如下：")]),t._v(" "),e("h3",{attrs:{id:"不定高虚拟列表实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不定高虚拟列表实现"}},[t._v("#")]),t._v(" 不定高虚拟列表实现")]),t._v(" "),e("p",[t._v("两种方案：")]),t._v(" "),e("ol",[e("li",[t._v("传入一个 estimateHeight 属性先对行高进行估计并渲染，然后渲染完成后获得真实行高并进行更新和缓存")])]),t._v(" "),e("blockquote",[e("p",[t._v("会引入多余的 transform（可以接受）")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("将当前元素先在屏外进行绘制并对齐高度进行测量后再将其渲染到用户可视区域内")])]),t._v(" "),e("blockquote",[e("p",[t._v("这种方法相当于双倍渲染消耗（不切实际）")])]),t._v(" "),e("h2",{attrs:{id:"长列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#长列表"}},[t._v("#")]),t._v(" 长列表")]),t._v(" "),e("p",[t._v("前端的业务开发中会遇到一些数据量较大且无法使用分页方式来加载的列表，我们一般把这种列表叫做长列表")]),t._v(" "),e("p",[t._v("完整渲染的长列表基本上很难达到业务上的要求的，非完整渲染的长列表一般有两种方式：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("懒渲染：这个就是常见的无线滚动的，每次只渲染一部分（比如 10 条），等剩余部分滚到可见区域，就再渲染一部分。")])]),t._v(" "),e("li",[e("p",[t._v("可视区域渲染：只渲染可见部分，不可见部分不渲染。")])])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("参考："),e("a",{attrs:{href:"https://juejin.cn/post/6948011958075392036",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何实现一个高度自适应的虚拟列表"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6844903982742110216",target:"_blank",rel:"noopener noreferrer"}},[t._v("「前端进阶」高性能渲染十万条数据(虚拟列表)"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://github.com/dwqs/blog/issues/70",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅说虚拟列表的实现原理"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://lkangd.com/post/virtual-infinite-scroll/",target:"_blank",rel:"noopener noreferrer"}},[t._v("剖析无限滚动虚拟列表的实现原理"),e("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=_.exports}}]);