(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{686:function(t,r,v){"use strict";v.r(r);var _=v(24),a=Object(_.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"html-开发问题总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html-开发问题总结"}},[t._v("#")]),t._v(" html 开发问题总结")]),t._v(" "),v("h3",{attrs:{id:"严格模式和混杂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#严格模式和混杂模式"}},[t._v("#")]),t._v(" 严格模式和混杂模式")]),t._v(" "),v("p",[t._v("严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。")]),t._v(" "),v("p",[t._v("混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。")]),t._v(" "),v("p",[t._v("区分：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）")])]),t._v(" "),v("li",[v("p",[t._v("有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式")])]),t._v(" "),v("li",[v("p",[t._v("DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD 不存在或者格式不正确——混杂模式）")])]),t._v(" "),v("li",[v("p",[t._v("HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）")])])]),t._v(" "),v("h3",{attrs:{id:"attribute-和-property-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#attribute-和-property-的区别"}},[t._v("#")]),t._v(" attribute 和 property 的区别")]),t._v(" "),v("p",[t._v("详解：")]),t._v(" "),v("p",[t._v("attribute： 是 dom 元素在文档中作为 html 标签拥有的属性，如 id,class,src,title,alt 等标签属性，")]),t._v(" "),v("p",[t._v("也可以自定义属性，通过 "),v("code",[t._v("dom.setAttribute('class', 'a')")]),t._v(" 来设置属性，通过 "),v("code",[t._v("dom.getAttribute('class', 'a')")]),t._v("来获取属性；")]),t._v(" "),v("p",[t._v("property: 就是 dom 元素在 js 中作为对象拥有的属性。 赋值 dom.className = 'a' ;取值 dom.className;")]),t._v(" "),v("p",[t._v("相同点：对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的。")]),t._v(" "),v("p",[t._v("区别：但是对于自定义的属性来说， "),v("code",[t._v('dom.test="";')]),t._v("没修改成功 。 test 自定义属性还存在。")]),t._v(" "),v("h3",{attrs:{id:"src-和-href-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#src-和-href-的区别"}},[t._v("#")]),t._v(" src 和 href 的区别")]),t._v(" "),v("ol",[v("li",[t._v("请求资源类型不同")])]),t._v(" "),v("p",[t._v("（1） href 是 Hypertext Reference 的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。")]),t._v(" "),v("p",[t._v("（2）在请求 src 资源时会将其指向的资源下载并应用到文档中，常用的有 script，img 、iframe；")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("作用结果不同")])]),t._v(" "),v("p",[t._v("（1）href 用于在当前文档和引用资源之间确立联系；")]),t._v(" "),v("p",[t._v("（2）src 用于替换当前内容；")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("浏览器解析方式不同")])]),t._v(" "),v("p",[t._v("（1）若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。")]),t._v(" "),v("p",[t._v("（2）当浏览器解析到 src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。")]),t._v(" "),v("h3",{attrs:{id:"link-和-import-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#link-和-import-的区别"}},[t._v("#")]),t._v(" link 和@import 的区别")]),t._v(" "),v("p",[t._v("两者都是外部引用 CSS 的方式，但是存在一定的区别：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("（1）link 是 XHTML 标签，除了能够加载 CSS，还可以定义 RSS 等其他事务；而@import 属于 CSS 范畴，只可以加载 CSS。")])]),t._v(" "),v("li",[v("p",[t._v("（2）link 引用 CSS 时，在页面载入时同时加载；@import 需要页面完全载入以后再加载。")])]),t._v(" "),v("li",[v("p",[t._v("（3）link 是 XHTML 标签，无兼容问题；@import 则是在 CSS2.1 提出的，低版本的浏览器不支持。")])]),t._v(" "),v("li",[v("p",[t._v("（4）link 支持使用 Javascript 控制 DOM 改变样式；而@import 不支持。")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);