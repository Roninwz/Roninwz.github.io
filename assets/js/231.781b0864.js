(window.webpackJsonp=window.webpackJsonp||[]).push([[231],{694:function(t,e,v){"use strict";v.r(e);var a=v(13),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"骨架屏"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#骨架屏"}},[t._v("#")]),t._v(" 骨架屏")]),t._v(" "),v("h3",{attrs:{id:"骨架屏方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#骨架屏方案"}},[t._v("#")]),t._v(" 骨架屏方案")]),t._v(" "),v("p",[t._v("（1） 手动书写骨架")]),t._v(" "),v("ol",[v("li",[t._v("使用图片、svg 或者手动编写骨架屏代码")])]),t._v(" "),v("p",[t._v("使用 HTML + CSS 的方式，我们可以很快的完成骨架屏效果，但是面对视觉设计的改版以及需求的更迭，我们对骨架屏的跟进修改会非常被动，这种机械化重复劳作的方式此时未免显得有些机动性不足")]),t._v(" "),v("p",[t._v("（2）自动生成骨架")]),t._v(" "),v("ol",[v("li",[t._v("通过预渲染手动书写的代码生成相应的骨架屏")])]),t._v(" "),v("p",[t._v("vue-skeleton-webpack-plugin，通过 vueSSR 结合 webpack 在构建时渲染写好的 vue 骨架屏组件，将预渲染生成的 DOM 节点和相关样式插入到最终输出的 html 中。")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("饿了么内部的生成骨架页面的工具（已不维护）")])]),t._v(" "),v("p",[t._v("该方案通过一个 webpack 插件 page-skeleton-webpack-plugin 的方式与项目开发无缝集成，属于在自动生成骨架屏方面做的非常强大的了，并且可以启动 UI 界面专门调整骨架屏，但是在面对复杂的页面也会有不尽如人意的地方，而且生成的骨架屏节点是基于页面本身的结构和 CSS，存在嵌套比较深的情况，体积不会太小，并且只支持 history 模式。")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("京东 dps")])]),t._v(" "),v("p",[t._v("结合 Puppeteer 自动生成骨架屏；")]),t._v(" "),v("p",[t._v("遍历页面上的节点，根据制定的规则生成相应区域的颜色块，最终形成页面的骨架屏；")])])}),[],!1,null,null,null);e.default=s.exports}}]);