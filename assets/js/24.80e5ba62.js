(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{439:function(e,a,v){e.exports=v.p+"assets/img/modular.79770b7b.png"},624:function(e,a,v){"use strict";v.r(a);var r=v(20),t=Object(r.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"前端模块化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端模块化"}},[e._v("#")]),e._v(" 前端模块化")]),e._v(" "),r("p",[r("img",{attrs:{src:v(439),alt:"image"}})]),e._v(" "),r("p",[e._v("JavaScript在早期的设计中就没有模块、包、类的概念，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。")]),e._v(" "),r("p",[e._v("模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。")]),e._v(" "),r("h3",{attrs:{id:"模块化优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块化优点"}},[e._v("#")]),e._v(" 模块化优点")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("避免命名冲突(减少命名空间污染)")])]),e._v(" "),r("li",[r("p",[e._v("更好的分离, 按需加载")])]),e._v(" "),r("li",[r("p",[e._v("提高代码复用率")])]),e._v(" "),r("li",[r("p",[e._v("提高了可维护性")])])]),e._v(" "),r("h2",{attrs:{id:"模块化规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块化规范"}},[e._v("#")]),e._v(" 模块化规范")]),e._v(" "),r("p",[e._v("常见的的JavaScript模块规范有：CommonJS、AMD、CMD、UMD、原生模块化")]),e._v(" "),r("h3",{attrs:{id:"commonjs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),r("p",[e._v("CommonJs 是服务器端模块的规范，Node.js采用了这个规范。")]),e._v(" "),r("p",[e._v("根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。")]),e._v(" "),r("p",[e._v("CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。")]),e._v(" "),r("h3",{attrs:{id:"amd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[e._v("#")]),e._v(" AMD")]),e._v(" "),r("p",[e._v("AMD：(Asynchromous Module Definition) 异步模块定义")]),e._v(" "),r("p",[e._v("AMD 是 RequireJS 在推广过程中对模块定义的规范化产出")]),e._v(" "),r("p",[e._v("AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。")]),e._v(" "),r("h3",{attrs:{id:"cmd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[e._v("#")]),e._v(" CMD")]),e._v(" "),r("p",[e._v("CMD（Common Module Definition）通用模块定义")]),e._v(" "),r("p",[e._v("CMD是SeaJS 在推广过程中对模块定义的规范化产出")]),e._v(" "),r("h3",{attrs:{id:"umd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#umd"}},[e._v("#")]),e._v(" UMD")]),e._v(" "),r("p",[e._v("UMD （Universal Module Definition）")]),e._v(" "),r("p",[e._v("UMD是AMD和CommonJS的综合产物。")]),e._v(" "),r("p",[e._v("AMD 浏览器第一的原则发展 异步加载模块。")]),e._v(" "),r("p",[e._v("CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。")]),e._v(" "),r("p",[e._v("这迫使人们又想出另一个更通用的模式UMD （Universal Module Definition）。希望解决跨平台的解决方案。")]),e._v(" "),r("p",[e._v("UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。")]),e._v(" "),r("p",[e._v("在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。")]),e._v(" "),r("h3",{attrs:{id:"原生js模块化-native-js"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原生js模块化-native-js"}},[e._v("#")]),e._v(" 原生JS模块化（Native JS）")]),e._v(" "),r("p",[e._v("上述的模块都不是原生 JavaScript 模块。它们只不过是我们用模块模式（module pattern）、CommonJS 或 AMD 模仿的模块系统。")]),e._v(" "),r("p",[e._v("JavaScript标准制定者在 TC39（该标准定义了 ECMAScript 的语法与语义）已经为 ECMAScript 6（ES6）引入内置的模块系统了。")]),e._v(" "),r("p",[e._v("相对于 CommonJS 或 AMD，ES6 模块如何设法提供两全其美的实现方案：简洁紧凑的声明式语法和异步加载，另外能更好地支持循环依赖。")]),e._v(" "),r("h3",{attrs:{id:"amd和cmd的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#amd和cmd的区别"}},[e._v("#")]),e._v(" AMD和CMD的区别")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。")])]),e._v(" "),r("li",[r("p",[e._v("AMD 推崇依赖前置。 CMD 推崇依赖就近，")])]),e._v(" "),r("li",[r("p",[e._v("对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）")])]),e._v(" "),r("li",[r("p",[e._v("AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹")])])]),e._v(" "),r("h3",{attrs:{id:"requirejs-和-seajs-区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#requirejs-和-seajs-区别"}},[e._v("#")]),e._v(" RequireJS 和 SeaJS 区别")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("两者定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。SeaJS 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 服务器端")])]),e._v(" "),r("li",[r("p",[e._v("两者遵循的标准有差异。RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。规范的不同，导致了两者 API 的不同。SeaJS 更简洁优雅，更贴近 CommonJS Modules/1.1 和 Node Modules 规范。")])]),e._v(" "),r("li",[r("p",[e._v("两者社区理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。SeaJS 不强推，而采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。")])]),e._v(" "),r("li",[r("p",[e._v("两者代码质量有差异。RequireJS 是没有明显的 bug，SeaJS 是明显没有 bug。")])]),e._v(" "),r("li",[r("p",[e._v("两者对调试等的支持有差异。SeaJS 通过插件，可以实现 Fiddler 中自动映射的功能，还可以实现自动 combo 等功能，非常方便便捷。RequireJS 无这方面的支持。")])]),e._v(" "),r("li",[r("p",[e._v("两者的插件机制有差异。RequireJS 采取的是在源码中预留接口的形式，源码中留有为插件而写的代码。SeaJS 采取的插件机制则与 Node 的方式一致：开放自身，让插件开发者可直接访问或修改，从而非常灵活，可以实现各种类型的插件。")])])])])}),[],!1,null,null,null);a.default=t.exports}}]);