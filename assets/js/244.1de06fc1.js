(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{771:function(e,t,a){"use strict";a.r(t);var r=a(14),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"webpack-原理总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-原理总结"}},[e._v("#")]),e._v(" webpack 原理总结")]),e._v(" "),a("h3",{attrs:{id:"webpack-的打包过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的打包过程"}},[e._v("#")]),e._v(" webpack 的打包过程")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数")])]),e._v(" "),a("li",[a("p",[e._v("开始编译 用上一步得到的参数初始 Compiler 对象，加载所有配置的插件，通 过执行对象的 run 方法开始执行编译")])]),e._v(" "),a("li",[a("p",[e._v("确定入口 根据配置中的 Entry 找出所有入口文件")])]),e._v(" "),a("li",[a("p",[e._v("编译模块 从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理")])]),e._v(" "),a("li",[a("p",[e._v("完成模块编译 在经过第 4 步使用 Loader 翻译完所有模块后， 得到了每个模块被编译后的最终内容及它们之间的依赖关系")])]),e._v(" "),a("li",[a("p",[e._v("输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk,再将每个 Chunk 转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会")])]),e._v(" "),a("li",[a("p",[e._v("输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，将文件的内容写入文件系统中。")])])]),e._v(" "),a("h3",{attrs:{id:"webpack-热更新原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-热更新原理"}},[e._v("#")]),e._v(" webpack 热更新原理")]),e._v(" "),a("p",[e._v("用 webpack-dev-server 启动一个服务之后，浏览器和服务端是通过 websocket 进行长连接，webpack 内部实现的 watch 就会监听文件修改，只要有修改就 webpack 会重新打包编译到内存中，然后 webpack-dev-server 依赖中间件 webpack-dev-middleware 和 webpack 之间进行交互，每次热更新都会请求一个携带 hash 值的 json 文件和一个 js，websocker 传递的也是 hash 值，内部机制通过 hash 值检查进行热更新， 至于内部原理，因为水平限制，目前还看不懂")]),e._v(" "),a("blockquote",[a("p",[e._v("参考："),a("a",{attrs:{href:"http://www.muyiy.cn/question/tool/70.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.muyiy.cn/question/tool/70.html"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"webpack-proxy-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-proxy-工作原理"}},[e._v("#")]),e._v(" Webpack Proxy 工作原理")]),e._v(" "),a("p",[e._v("通过 webpack-dev-server 提供一个代理服务器实现跨域")]),e._v(" "),a("p",[e._v("底层通过 http-proxy-middleware 这个 http 代理中间件，实现请求转发给其他服务器")]),e._v(" "),a("blockquote",[a("p",[e._v("参考："),a("a",{attrs:{href:"https://www.cnblogs.com/houxianzhou/p/14743623.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/houxianzhou/p/14743623.html"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"webpack-打包的具体原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-打包的具体原理"}},[e._v("#")]),e._v(" Webpack 打包的具体原理")]),e._v(" "),a("ul",[a("li",[e._v("利用 babel 完成代码转换,并生成单个文件的依赖")]),e._v(" "),a("li",[e._v("从入口开始递归分析，并生成依赖图谱")]),e._v(" "),a("li",[e._v("将各个引用模块打包为一个立即执行函数")]),e._v(" "),a("li",[e._v("将最终的 bundle 文件写入 bundle.js 中")])]),e._v(" "),a("h3",{attrs:{id:"webpack-拆包-代码分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-拆包-代码分离"}},[e._v("#")]),e._v(" webpack 拆包(代码分离)")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("入口起点：使用 "),a("a",{attrs:{href:"https://webpack.docschina.org/configuration/entry-context",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("entry")]),a("OutboundLink")],1),e._v(" 配置手动地分离代码。")])]),e._v(" "),a("li",[a("p",[e._v("防止重复：使用 "),a("a",{attrs:{href:"https://webpack.docschina.org/plugins/split-chunks-plugin/",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("SplitChunksPlugin")]),a("OutboundLink")],1),e._v(" 去重和分离 chunk。")])]),e._v(" "),a("li",[a("p",[e._v("动态导入：通过模块中的内联函数调用来分离代码。")])])]),e._v(" "),a("p",[e._v("使用 webpack 拆包功能，从 bundle.js 中拆分出多个 chunk.js，实现 js 的按需加载，可以提高首屏加载速度")]),e._v(" "),a("p",[e._v("webpack4 取消了 CommonsChunkPlugin，使用 splitChunks 进行拆包")]),e._v(" "),a("h3",{attrs:{id:"import-被-webpack-编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#import-被-webpack-编译"}},[e._v("#")]),e._v(" import 被 webpack 编译")]),e._v(" "),a("blockquote",[a("p",[e._v("问题：import moduleName from 'xxModule'和 import('xxModule')经过 webpack 编译打包后最终变成了什么？在浏览器中是怎么运行的？")])]),e._v(" "),a("p",[e._v("webpack 将所有的 import moduleName from 'xxModule'都变成了一个 Map 对象，key 为文件路径，value 为一个可执行的函数，而函数内容其实就是模块中导出的内容，")]),e._v(" "),a("p",[e._v("异步方法（import('xxModule')）比较特殊一些，它会单独打成一个包，采用动态加载的方式，")]),e._v(" "),a("blockquote",[a("p",[e._v("参考："),a("a",{attrs:{href:"https://www.cnblogs.com/goloving/p/14075523.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/goloving/p/14075523.html"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文章"}},[e._v("#")]),e._v(" 文章")]),e._v(" "),a("ul",[a("li",[e._v("webpack 系列--浅析 webpack 的原理")])]),e._v(" "),a("blockquote",[a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/chengxs/p/11022842.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/chengxs/p/11022842.html"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=o.exports}}]);