(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{449:function(e,v,a){e.exports=a.p+"assets/img/modular.79770b7b.png"},648:function(e,v,a){"use strict";a.r(v);var _=a(24),r=Object(_.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"前端模块化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端模块化"}},[e._v("#")]),e._v(" 前端模块化")]),e._v(" "),_("p",[_("img",{attrs:{src:a(449),alt:"image"}})]),e._v(" "),_("p",[e._v("JavaScript 在早期的设计中就没有模块、包、类的概念，开发者需要模拟出类似的功能，来隔离、组织复杂的 JavaScript 代码，我们称为模块化。")]),e._v(" "),_("p",[e._v("模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。")]),e._v(" "),_("h3",{attrs:{id:"模块化优点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化优点"}},[e._v("#")]),e._v(" 模块化优点")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("避免命名冲突(减少命名空间污染)")])]),e._v(" "),_("li",[_("p",[e._v("更好的分离, 按需加载")])]),e._v(" "),_("li",[_("p",[e._v("提高代码复用率")])]),e._v(" "),_("li",[_("p",[e._v("提高了可维护性")])])]),e._v(" "),_("h2",{attrs:{id:"模块化规范"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化规范"}},[e._v("#")]),e._v(" 模块化规范")]),e._v(" "),_("p",[e._v("常见的的 JavaScript 模块规范有：CommonJS、AMD、CMD、UMD、原生模块化，ES6 模块化")]),e._v(" "),_("h3",{attrs:{id:"commonjs"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),_("p",[e._v("CommonJs 是服务器端模块的规范，Node.js 采用了这个规范。")]),e._v(" "),_("p",[e._v("根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 require 方法，该方法读取一个文件并执行，最后返回文件内部的 exports 对象。")]),e._v(" "),_("p",[e._v("CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以 CommonJS 规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD CMD 解决方案。")]),e._v(" "),_("h3",{attrs:{id:"amd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[e._v("#")]),e._v(" AMD")]),e._v(" "),_("p",[e._v("AMD：(Asynchromous Module Definition) 异步模块定义")]),e._v(" "),_("p",[e._v("AMD 是 RequireJS 在推广过程中对模块定义的规范化产出")]),e._v(" "),_("p",[e._v("AMD 异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON 等各种类型的模块。")]),e._v(" "),_("p",[e._v("AMD 推崇依赖前置")]),e._v(" "),_("p",[e._v("对于依赖的模块，AMD 是提前执行")]),e._v(" "),_("h3",{attrs:{id:"cmd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[e._v("#")]),e._v(" CMD")]),e._v(" "),_("p",[e._v("CMD（Common Module Definition）通用模块定义")]),e._v(" "),_("p",[e._v("CMD 是 SeaJS 在推广过程中对模块定义的规范化产出")]),e._v(" "),_("p",[e._v("CMD 推崇依赖就近")]),e._v(" "),_("p",[e._v("对于依赖的模块，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）")]),e._v(" "),_("h3",{attrs:{id:"umd"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#umd"}},[e._v("#")]),e._v(" UMD")]),e._v(" "),_("p",[e._v("UMD （Universal Module Definition）")]),e._v(" "),_("p",[e._v("UMD 是 AMD 和 CommonJS 的综合产物。")]),e._v(" "),_("p",[e._v("AMD 浏览器第一的原则发展 异步加载模块。")]),e._v(" "),_("p",[e._v("CommonJS 模块以服务器第一原则发展，选择同步加载，它的模块无需包装(unwrapped modules)。")]),e._v(" "),_("p",[e._v("这迫使人们又想出另一个更通用的模式 UMD （Universal Module Definition）。希望解决跨平台的解决方案。")]),e._v(" "),_("p",[e._v("UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。")]),e._v(" "),_("p",[e._v("在判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。")]),e._v(" "),_("h3",{attrs:{id:"es6-模块化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块化"}},[e._v("#")]),e._v(" ES6 模块化")]),e._v(" "),_("p",[e._v("ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。而 CommonJS 和 CMD，都只能在运行时确定依赖。")]),e._v(" "),_("p",[e._v("可以进行可靠的静态分析，进而进行 tree-shaking")]),e._v(" "),_("p",[e._v("ES6 模块化特点：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("只能作为模块顶层的语句出现")])]),e._v(" "),_("li",[_("p",[e._v("import 的模块名只能是字符串常量")])]),e._v(" "),_("li",[_("p",[e._v("import binding 是 immutable 的")])])]),e._v(" "),_("h3",{attrs:{id:"原生-js-模块化-native-js"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原生-js-模块化-native-js"}},[e._v("#")]),e._v(" 原生 JS 模块化（Native JS）")]),e._v(" "),_("p",[e._v("上述的模块都不是原生 JavaScript 模块。它们只不过是我们用模块模式（module pattern）、CommonJS 或 AMD 模仿的模块系统。")]),e._v(" "),_("p",[e._v("JavaScript 标准制定者在 TC39（该标准定义了 ECMAScript 的语法与语义）已经为 ECMAScript 6（ES6）引入内置的模块系统了。")]),e._v(" "),_("p",[e._v("相对于 CommonJS 或 AMD，ES6 模块如何设法提供两全其美的实现方案：简洁紧凑的声明式语法和异步加载，另外能更好地支持循环依赖。")]),e._v(" "),_("h3",{attrs:{id:"amd-和-cmd-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#amd-和-cmd-的区别"}},[e._v("#")]),e._v(" AMD 和 CMD 的区别")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。")])]),e._v(" "),_("li",[_("p",[e._v("AMD 推崇依赖前置。 CMD 推崇依赖就近，")])]),e._v(" "),_("li",[_("p",[e._v("对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）")])]),e._v(" "),_("li",[_("p",[e._v("AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹")])])]),e._v(" "),_("h3",{attrs:{id:"es6-模块与-commonjs-模块的差异"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#es6-模块与-commonjs-模块的差异"}},[e._v("#")]),e._v(" ES6 模块与 CommonJS 模块的差异")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("① CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。")])]),e._v(" "),_("li",[_("p",[e._v("② CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")])])]),e._v(" "),_("p",[e._v("CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。")]),e._v(" "),_("h3",{attrs:{id:"requirejs-和-seajs-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#requirejs-和-seajs-区别"}},[e._v("#")]),e._v(" RequireJS 和 SeaJS 区别")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("两者定位有差异。RequireJS 想成为浏览器端的模块加载器，同时也想成为 Rhino / Node 等环境的模块加载器。SeaJS 则专注于 Web 浏览器端，同时通过 Node 扩展的方式可以很方便跑在 Node 服务器端")])]),e._v(" "),_("li",[_("p",[e._v("两者遵循的标准有差异。RequireJS 遵循的是 AMD（异步模块定义）规范，SeaJS 遵循的是 CMD （通用模块定义）规范。规范的不同，导致了两者 API 的不同。SeaJS 更简洁优雅，更贴近 CommonJS Modules/1.1 和 Node Modules 规范。")])]),e._v(" "),_("li",[_("p",[e._v("两者社区理念有差异。RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。SeaJS 不强推，而采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。")])]),e._v(" "),_("li",[_("p",[e._v("两者代码质量有差异。RequireJS 是没有明显的 bug，SeaJS 是明显没有 bug。")])]),e._v(" "),_("li",[_("p",[e._v("两者对调试等的支持有差异。SeaJS 通过插件，可以实现 Fiddler 中自动映射的功能，还可以实现自动 combo 等功能，非常方便便捷。RequireJS 无这方面的支持。")])]),e._v(" "),_("li",[_("p",[e._v("两者的插件机制有差异。RequireJS 采取的是在源码中预留接口的形式，源码中留有为插件而写的代码。SeaJS 采取的插件机制则与 Node 的方式一致：开放自身，让插件开发者可直接访问或修改，从而非常灵活，可以实现各种类型的插件。")])])])])}),[],!1,null,null,null);v.default=r.exports}}]);