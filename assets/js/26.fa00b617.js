(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{452:function(t,a,s){t.exports=s.p+"assets/img/stack_memory.26e872ee.png"},738:function(t,a,s){"use strict";s.r(a);var n=s(24),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"内存生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存生命周期"}},[t._v("#")]),t._v(" 内存生命周期")]),t._v(" "),n("p",[t._v("不管什么程序语言，内存生命周期基本是一致的：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("分配内存")])]),t._v(" "),n("li",[n("p",[t._v("使用内存（读或写）")])]),t._v(" "),n("li",[n("p",[t._v("释放内存")])])]),t._v(" "),n("h3",{attrs:{id:"内存管理系统-手动-or-自动"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存管理系统-手动-or-自动"}},[t._v("#")]),t._v(" 内存管理系统：手动 or 自动")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("低级语言：像 C 语言这样的低级语言一般都有底层的内存管理接口，比如 malloc()和 free()。")])]),t._v(" "),n("li",[n("p",[t._v("高级语言：JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。 释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。")])])]),t._v(" "),n("p",[t._v("内存：由可读写单元组成，表示一片可操作空间；")]),t._v(" "),n("p",[t._v("管理：人为的去操作一片空间的申请、使用和释放；")]),t._v(" "),n("p",[t._v("内存管理：开发者主动申请空间、使用空间、释放空间；")]),t._v(" "),n("p",[t._v("管理流程：申请-使用-释放")]),t._v(" "),n("h3",{attrs:{id:"内存引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存引用"}},[t._v("#")]),t._v(" 内存引用")]),t._v(" "),n("p",[t._v("如果一个对象可以访问另一个对象（可以是隐式的或显式的），则称该对象引用另一个对象。例如, 一个 JavaScript 引用了它的 prototype (隐式引用)和它的属性值(显式引用)。")]),t._v(" "),n("h2",{attrs:{id:"内存泄漏"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),n("p",[t._v("内存泄漏 memory leak：是指程序在申请内存后，无法释放已申请的内存空间")]),t._v(" "),n("p",[t._v("一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。")]),t._v(" "),n("p",[t._v("memory leak 会最终会导致 out of memory！")]),t._v(" "),n("p",[t._v("合理的使用 WeakMap 和 WeakSet，能帮助我们避免内存泄漏")]),t._v(" "),n("p",[t._v("常见的内存泄漏：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("意外的全局变量")])]),t._v(" "),n("li",[n("p",[t._v("dom 清空时，还存在引用")])]),t._v(" "),n("li",[n("p",[t._v("定时器中的内存泄漏")])]),t._v(" "),n("li",[n("p",[t._v("不规范地使用闭包")])])]),t._v(" "),n("h3",{attrs:{id:"_1-意外的全局变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-意外的全局变量"}},[t._v("#")]),t._v(" 1. 意外的全局变量")]),t._v(" "),n("p",[t._v("变量并没有声明.JS 就会默认将它变为全局变量,这样在页面关闭之前都不会被释放.")]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bar "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar没有被声明!"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br")])]),n("p",[t._v("避免：使用严格模式")]),t._v(" "),n("h3",{attrs:{id:"_2-dom-清空时-还存在引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-dom-清空时-还存在引用"}},[t._v("#")]),t._v(" 2.dom 清空时，还存在引用")]),t._v(" "),n("p",[t._v("很多时候,为了方便存取,经常会将 DOM 结点暂时存储到数据结构中.但是在不需要该 DOM 节点时,忘记解除对它的引用,则会造成内存泄露.")]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" refA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"refA"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndocument"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("body"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeChild")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("refA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dom删除了")]),t._v("\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("refA"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"refA"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 但是还存在引用")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 去掉DOM节点的引用")]),t._v("\nrefA "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br")])]),n("p",[t._v("与此类似情景还有: DOM 节点绑定了事件, 但是在移除的时候没有解除事件绑定,那么仅仅移除 DOM 节点也是没用的")]),t._v(" "),n("p",[t._v("避免：dom 引用置为 null")]),t._v(" "),n("h3",{attrs:{id:"_3-被遗忘的定时器和回调函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-被遗忘的定时器和回调函数"}},[t._v("#")]),t._v(" 3. 被遗忘的定时器和回调函数")]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" someResource "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getData")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInterval")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" node "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Node'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        node"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("innerHTML "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("JSON")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("stringify")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("someResource"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br")])]),n("p",[t._v("如果没有清除定时器,那么 someResource 就不会被释放,如果刚好它又占用了较大内存,就会引发性能问题. 但是 setTimeout ,它计时结束后它的回调里面引用的对象占用的内存是可以被回收的. 当然有些场景 setTimeout 的计时可能很长, 这样的情况下也是需要纳入考虑的.")]),t._v(" "),n("p",[t._v("避免： 在定时器完成工作的时候，手动清除定时器")]),t._v(" "),n("h3",{attrs:{id:"_4-不规范地使用闭包"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-不规范地使用闭包"}},[t._v("#")]),t._v(" 4. 不规范地使用闭包")]),t._v(" "),n("p",[t._v("相互循环引用")]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("bar")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fn "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bar"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" bar"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br")])]),n("p",[t._v("bar 作为一个闭包,即使它内部什么都没有,foo 中的所有变量都还是隐式地被 bar 所引用。 即使 bar 内什么都没有还是造成了循环引用,那真正的解决办法就是,不要将 a.fn = bar.")]),t._v(" "),n("p",[t._v("注意点：")]),t._v(" "),n("p",[t._v("闭包，闭包和内存泄漏没有半毛钱关系，只是由于 IE9 之前的版本垃圾收集机制的原因，导致内存无法进行回收，这是 IE 的问题，现代浏览器基本都不存在这个问题。当然闭包要是使用不当肯定是会造成内存泄漏。")]),t._v(" "),n("h3",{attrs:{id:"vue-中的内存泄漏"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的内存泄漏"}},[t._v("#")]),t._v(" vue 中的内存泄漏")]),t._v(" "),n("ol",[n("li",[t._v("DOM 中的 addEventLisner 函数及派生的事件监听没有解除绑定")])]),t._v(" "),n("p",[t._v("解决办法：需要在 beforeDestroy 中做对应解绑处理；")]),t._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[t._v("组件中使用了 setInterval，需要在 beforeDestroy 中做对应销毁处理")])]),t._v(" "),n("h3",{attrs:{id:"怎么避免内存泄漏"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#怎么避免内存泄漏"}},[t._v("#")]),t._v(" 怎么避免内存泄漏")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收(即赋值为 null)；")])]),t._v(" "),n("li",[n("p",[t._v("避免循环引用，避免“死循环”之类的 ；")])]),t._v(" "),n("li",[n("p",[t._v("避免创建过多的对象 原则：不用了的东西要记得及时归还。")])]),t._v(" "),n("li",[n("p",[t._v("减少层级过多的引用")])])]),t._v(" "),n("h2",{attrs:{id:"内存溢出"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出"}},[t._v("#")]),t._v(" 内存溢出")]),t._v(" "),n("p",[t._v("内存溢出 out of memory：是一种程序运行出现的错误， 是指程序在申请内存时，没有足够的内存空间供其使用")]),t._v(" "),n("h3",{attrs:{id:"内存溢出的原因"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出的原因"}},[t._v("#")]),t._v(" 内存溢出的原因")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("内存中加载的数据量过于庞大，如一次从数据库取出过多数据；")])]),t._v(" "),n("li",[n("p",[t._v("集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收；")])]),t._v(" "),n("li",[n("p",[t._v("代码中存在死循环或循环产生过多重复的对象实体；")])]),t._v(" "),n("li",[n("p",[t._v("使用的第三方软件中的 BUG；")])]),t._v(" "),n("li",[n("p",[t._v("启动参数内存值设定的过小")])])]),t._v(" "),n("h3",{attrs:{id:"内存溢出的解决方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出的解决方案"}},[t._v("#")]),t._v(" 内存溢出的解决方案")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("修改 JVM 启动参数，直接增加内存。(-Xms，-Xmx 参数一定不要忘记加。)")])]),t._v(" "),n("li",[n("p",[t._v("检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。")])]),t._v(" "),n("li",[n("p",[t._v("检查代码中是否有死循环或递归调用")])]),t._v(" "),n("li",[n("p",[t._v("检查是否有大循环重复产生新对象实体。")])]),t._v(" "),n("li",[n("p",[t._v("检查对数据库查询中，是否有一次获得全部数据的查询(如果一次取十万条记录到内存，就可能引起内存溢出)")])])]),t._v(" "),n("h2",{attrs:{id:"栈内存和堆内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈内存和堆内存"}},[t._v("#")]),t._v(" 栈内存和堆内存")]),t._v(" "),n("blockquote",[n("p",[t._v("参考：「前端进阶」JS 中的栈内存堆内存"),n("a",{attrs:{href:"https://juejin.cn/post/6844903873992196110",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.cn/post/6844903873992196110"),n("OutboundLink")],1)])]),t._v(" "),n("p",[t._v("指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定")]),t._v(" "),n("h3",{attrs:{id:"栈内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈内存"}},[t._v("#")]),t._v(" 栈内存")]),t._v(" "),n("h3",{attrs:{id:"堆内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#堆内存"}},[t._v("#")]),t._v(" 堆内存")]),t._v(" "),n("h3",{attrs:{id:"栈内存和堆内存对比"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈内存和堆内存对比"}},[t._v("#")]),t._v(" 栈内存和堆内存对比")]),t._v(" "),n("p",[n("img",{attrs:{src:s(452),alt:"image"}})]),t._v(" "),n("p",[t._v("栈内存和堆内存的优缺点：")]),t._v(" "),n("p",[t._v("在 JS 中，基本数据类型变量大小固定，并且操作简单容易，所以把它们放入栈中存储。\n引用类型变量大小不固定，所以把它们分配给堆中，让他们申请空间的时候自己确定大小，这样把它们分开存储能够使得程序运行起来占用的内存最小。")]),t._v(" "),n("p",[t._v("栈内存由于它的特点，所以它的系统效率较高。")]),t._v(" "),n("p",[t._v("堆内存需要分配空间和地址，还要把地址存到栈中，所以效率低于栈。")]),t._v(" "),n("h3",{attrs:{id:"闭包与堆内存"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#闭包与堆内存"}},[t._v("#")]),t._v(" 闭包与堆内存")]),t._v(" "),n("p",[t._v("闭包中的变量并不保存中栈内存中，而是保存在堆内存中。 这也就解释了函数调用之后之后为什么闭包还能引用到函数内的变量。")]),t._v(" "),n("h3",{attrs:{id:"栈内存和堆内存的垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#栈内存和堆内存的垃圾回收"}},[t._v("#")]),t._v(" 栈内存和堆内存的垃圾回收")]),t._v(" "),n("p",[t._v("栈内存中变量一般在它的当前执行环境结束就会被销毁被垃圾回收制回收， 而堆内存中的变量则不会，因为不确定其他的地方是不是还有一些对它的引用。 堆内存中的变量只有在所有对它的引用都结束的时候才会被回收。")]),t._v(" "),n("h2",{attrs:{id:"js-垃圾回收"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-垃圾回收"}},[t._v("#")]),t._v(" js 垃圾回收")]),t._v(" "),n("p",[t._v("浏览器的 Javascript 具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大并且 GC 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。")]),t._v(" "),n("p",[t._v("垃圾：")]),t._v(" "),n("p",[t._v("一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。")]),t._v(" "),n("p",[t._v("JavaScript 中会被判定为垃圾的情形如下：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("对象不再被引用；")])]),t._v(" "),n("li",[n("p",[t._v("对象不能从根上访问到；")])])]),t._v(" "),n("p",[t._v("垃圾回收算法：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("标记清除")])]),t._v(" "),n("li",[n("p",[t._v("引用计数")])]),t._v(" "),n("li",[n("p",[t._v("标记整理")])]),t._v(" "),n("li",[n("p",[t._v("分代回收")])])]),t._v(" "),n("h3",{attrs:{id:"_1-标记清除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-标记清除"}},[t._v("#")]),t._v(" 1.标记清除")]),t._v(" "),n("p",[t._v("标记清除算法由两个阶段组成:")]),t._v(" "),n("p",[t._v("第一阶段：标记阶段，标记所有的可访问对象.")]),t._v(" "),n("p",[t._v("第二阶段：清除阶段，垃圾收集算法扫描堆并回收所有的未标记对象.")]),t._v(" "),n("p",[t._v("流程：")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("垃圾收集器找到所有的根，并“标记”（记住）它们。")])]),t._v(" "),n("li",[n("p",[t._v("然后它遍历并“标记”来自它们的所有引用。")])]),t._v(" "),n("li",[n("p",[t._v("然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。")])]),t._v(" "),n("li",[n("p",[t._v("……如此操作，直到所有可达的（从根部）引用都被访问到。")])]),t._v(" "),n("li",[n("p",[t._v("没有被标记的对象都会被删除。")])])]),t._v(" "),n("p",[t._v("标记清除算法有两个很明显的缺点：")]),t._v(" "),n("p",[t._v("● 内存碎片化，在清除之后，剩余的对象内存位置是不变的，会导致空闲内存空间是不连续的，容易出现很多空闲内存块（内存碎片），还可能会出现分配所需内存过大的对象时找不到合适的块。")]),t._v(" "),n("p",[t._v("● 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。")]),t._v(" "),n("blockquote",[n("p",[t._v("循环引用不再是问题了，两个循环引用的对象在垃圾收集时从全局对象出发无法再获取他们的引用。 因此，他们将会被垃圾回收器回收。")])]),t._v(" "),n("h3",{attrs:{id:"_2-引用计数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用计数"}},[t._v("#")]),t._v(" 2.引用计数")]),t._v(" "),n("p",[t._v("如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。")]),t._v(" "),n("p",[t._v("缺点：")]),t._v(" "),n("p",[t._v("引用计数法是最初级的垃圾收集算法，如果某对象没有其他对象指向它了，那就说明它可以被回收。但是它无法处理"),n("strong",[t._v("循环引用")]),t._v("的问题。")]),t._v(" "),n("p",[t._v("循环引用时，两个对象都至少被引用了一次，将不能自动被回收。所以导致，我们常讲的内存泄露。")]),t._v(" "),n("h3",{attrs:{id:"_3-标记整理-mark-compact"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-标记整理-mark-compact"}},[t._v("#")]),t._v(" 3.标记整理（Mark-Compact）")]),t._v(" "),n("p",[t._v("为了解决内存碎片化的问题，提高对内存的利用，引入了标记整理算法。")]),t._v(" "),n("p",[t._v("标记整理可以看做是标记清除的增强。")]),t._v(" "),n("p",[t._v("标记阶段的操作和标记清除一致。清除阶段会先执行整理，移动对象位置,将存活的对象移动到一边，然后再清理端边界外的内存。")]),t._v(" "),n("p",[t._v("标记整理的缺点是：移动对象位置，不会立即回收对象，回收的效率比较慢。")]),t._v(" "),n("h3",{attrs:{id:"javascript-引擎对垃圾回收应用了许多优化-使其运行得更快-并且不影响执行。"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-引擎对垃圾回收应用了许多优化-使其运行得更快-并且不影响执行。"}},[t._v("#")]),t._v(" JavaScript 引擎对垃圾回收应用了许多优化，使其运行得更快，并且不影响执行。")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结 ，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。")])]),t._v(" "),n("li",[n("p",[t._v("增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。")])]),t._v(" "),n("li",[n("p",[t._v("空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。")])])]),t._v(" "),n("h3",{attrs:{id:"v8-的-gc-机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#v8-的-gc-机制"}},[t._v("#")]),t._v(" V8 的 GC 机制")]),t._v(" "),n("p",[t._v("V8 中的垃圾回收主要使用的是 分代回收 (Generational collection)机制。")]),t._v(" "),n("p",[t._v("V8 中将堆内存分为 新生代 和 老生代 两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收。")]),t._v(" "),n("p",[t._v("（1）新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。简单来说就是新产生的对象，通常只支持 1 ～ 8M 的容量，")]),t._v(" "),n("p",[t._v("（2）老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象(常驻内存的对象)。简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大。")]),t._v(" "),n("p",[t._v("回收新生代对象主要采用复制算法（Scavenge 算法）加标记整理算法。而 Scavenge 算法的具体实现，主要采用了 Cheney 算法。")]),t._v(" "),n("p",[t._v("回收老生代对象主要采用标记清除、标记整理、增量标记算法，主要使用标记清除算法，只有在内存分配不足时，采用标记整理算法。")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("首先使用标记清除完成垃圾空间的回收；")])]),t._v(" "),n("li",[n("p",[t._v("采用标记整理进行空间优化；")])]),t._v(" "),n("li",[n("p",[t._v("采用增量标记进行效率优化；")])])]),t._v(" "),n("p",[t._v("新生代和老生代回收对比")]),t._v(" "),n("ol",[n("li",[n("p",[t._v("新生代由于占用空间比较少，采用空间换时间机制。")])]),t._v(" "),n("li",[n("p",[t._v("老生代区域空间比较大，不太适合大量的复制算法和标记整理，所以最常用的是标记清除算法，为了就是让全停顿的时间尽量减少。")])])]),t._v(" "),n("h2",{attrs:{id:"js-垃圾回收问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-垃圾回收问题"}},[t._v("#")]),t._v(" js 垃圾回收问题")]),t._v(" "),n("h3",{attrs:{id:"_1-什么是垃圾"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是垃圾"}},[t._v("#")]),t._v(" 1.什么是垃圾")]),t._v(" "),n("p",[t._v("一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。")])])}),[],!1,null,null,null);a.default=r.exports}}]);