(window.webpackJsonp=window.webpackJsonp||[]).push([[267],{732:function(e,t,a){"use strict";a.r(t);var r=a(24),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"typescript"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[e._v("#")]),e._v(" typescript")]),e._v(" "),a("p",[e._v("TS 中对于被标记为 any 类型的变量，是没有进行类型检查而直接通过编译阶段的检查。")]),e._v(" "),a("h3",{attrs:{id:"never-和-void-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#never-和-void-区别"}},[e._v("#")]),e._v(" never 和 void 区别")]),e._v(" "),a("p",[e._v("void 表示没有任何类型（可以被赋值为 null 和 undefined）。拥有 void 返回值类型的函数能正常运行。")]),e._v(" "),a("p",[e._v("never 表示一个不包含值的类型，即表示永远不存在的值。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。")]),e._v(" "),a("h3",{attrs:{id:"type-和-interface-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-和-interface-的区别"}},[e._v("#")]),e._v(" type 和 interface 的区别")]),e._v(" "),a("p",[e._v("在 ts 中，定义类型由两种方式：接口（interface）和类型别名（type alias）")]),e._v(" "),a("p",[e._v("相同点：")]),e._v(" "),a("ol",[a("li",[e._v("都可以描述一个对象或者函数")])]),e._v(" "),a("p",[e._v("区别：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("interface 只能定义对象类型，type 声明的方式可以定义组合类型，交叉类型和原始类型")])]),e._v(" "),a("li",[a("p",[e._v("interface 方式可以实现接口的 extends/implements，而 type 不行")])]),e._v(" "),a("li",[a("p",[e._v("interface 可以声明合并，但是 type 不行")])])]),e._v(" "),a("h3",{attrs:{id:"泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[e._v("#")]),e._v(" 泛型")]),e._v(" "),a("p",[e._v("泛型是一种创建可复用代码组件的工具。这种组件不只能被一种类型使用，而是能被多种类型复用。类似于参数的作用，泛型是一种用以增强类（classes）、类型（types）和接口（interfaces）能力的非常可靠的手段。这样，我们开发者，就可以轻松地将那些可复用的代码组件，适用于各种输入。")]),e._v(" "),a("h3",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[e._v("#")]),e._v(" 接口")]),e._v(" "),a("p",[e._v("适用场景：从服务器端获取或者业务场景中模拟的数据，这些数据通常是不会经常变化和调整的，这些数据可能仅仅只表示某些状态，或者是 UI 上的文本。提倡使用 interface 去定义")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("Typescript 打包编译原理")])])}),[],!1,null,null,null);t.default=v.exports}}]);