(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{521:function(t,r,a){t.exports=a.p+"assets/img/SSR.dd8b8aa4.png"},774:function(t,r,a){"use strict";a.r(r);var e=a(14),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"服务器端渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器端渲染"}},[t._v("#")]),t._v(" 服务器端渲染")]),t._v(" "),e("p",[t._v("Server-Side Rendering 我们称其为 SSR，意为服务端渲染")]),t._v(" "),e("p",[t._v("是指在服务端完成页面的 html 拼接处理， 然后再发送给浏览器，将不具有交互能力的 html 结构绑定事件和状态，在客户端展示为具有完整交互能力的应用程序。")]),t._v(" "),e("h3",{attrs:{id:"服务器端渲染优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器端渲染优点"}},[t._v("#")]),t._v(" 服务器端渲染优点")]),t._v(" "),e("ol",[e("li",[t._v("更好的 SEO")])]),t._v(" "),e("p",[t._v("优势在于同步。搜索引擎爬虫是不会等待异步请求数据结束后再抓取信息的，如果 SEO 对应用程序至关重要，但你的页面又是异步请求数据，那 SSR 可以帮助你很好的解决这个问题。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("更快的内容到达时间")])]),t._v(" "),e("p",[t._v("优势在于慢网络和运行缓慢的设备场景。传统 SPA 需完整的 JS 下载完成才可执行，而 SSR 服务器渲染标记在服务端渲染 html 后即可显示，用户会更快的看到首屏渲染页面。如果首屏渲染时间转化率对应用程序至关重要，那可以使用 SSR 来优化。")]),t._v(" "),e("h3",{attrs:{id:"不适合场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#不适合场景"}},[t._v("#")]),t._v(" 不适合场景")]),t._v(" "),e("p",[t._v("以下三种场景 SSR 使用需要慎重：")]),t._v(" "),e("ol",[e("li",[t._v("同构资源的处理")])]),t._v(" "),e("p",[t._v("劣势在于程序需要具有通用性。结合 Vue 的钩子来说，能在 SSR 中调用的生命周期只有 beforeCreate 和 created，这就导致在使用三方 API 时必须保证运行不报错。在三方库的引用时需要特殊处理使其支持服务端和客户端都可运行。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("部署构建配置资源的支持")])]),t._v(" "),e("p",[t._v("劣势在于运行环境单一。程序需处于 node.js server 运行环境。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("服务器更多的缓存准备")])]),t._v(" "),e("p",[t._v("劣势在于高流量场景需采用缓存策略。应用代码需在双端运行解析，cpu 性能消耗更大，负载均衡和多场景缓存处理比 SPA 做更多准备。")]),t._v(" "),e("h3",{attrs:{id:"同构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同构"}},[t._v("#")]),t._v(" 同构")]),t._v(" "),e("p",[t._v("同构指的就是 SSR（server-side rending 翻译过来就是服务器渲染）的一种，只是它强调服务端跟客户端公用一套代码。服务端去渲染，客户端来负责交互。当然服务端渲染挂了，客户端也是可以渲染的。")]),t._v(" "),e("h3",{attrs:{id:"服务器端渲染应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器端渲染应用"}},[t._v("#")]),t._v(" 服务器端渲染应用")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("React 的(Next.js)")])]),t._v(" "),e("li",[e("p",[t._v("Vue 的(Nuxt.js)")])]),t._v(" "),e("li",[e("p",[t._v("Angular: Nest.js")])])]),t._v(" "),e("h2",{attrs:{id:"服务器端渲染问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务器端渲染问题"}},[t._v("#")]),t._v(" 服务器端渲染问题")]),t._v(" "),e("h3",{attrs:{id:"ssr-和-csr-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssr-和-csr-的区别"}},[t._v("#")]),t._v(" SSR 和 CSR 的区别")]),t._v(" "),e("p",[e("img",{attrs:{src:a(521),alt:"image"}})]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("参考："),e("a",{attrs:{href:"https://z.itpub.net/article/detail/34E41474DCC1918B2120F660F462FF3B",target:"_blank",rel:"noopener noreferrer"}},[t._v("服务端渲染 SSR 及实现原理"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://github.com/yacan8/blog/issues/30",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底理解服务端渲染 - SSR 原理"),e("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=s.exports}}]);