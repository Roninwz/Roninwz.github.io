(window.webpackJsonp=window.webpackJsonp||[]).push([[291],{756:function(v,_,d){"use strict";d.r(_);var e=d(24),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,d=v._self._c||_;return d("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[d("h2",{attrs:{id:"虚拟-dom"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[v._v("#")]),v._v(" 虚拟 DOM")]),v._v(" "),d("p",[v._v("虚拟 DOM，就是用一个 JS 对象来描述一个 DOM 节点，就是以 JS 的计算性能来换取操作真实 DOM 所消耗的性能")]),v._v(" "),d("p",[v._v("源码解析：")]),v._v(" "),d("p",[v._v("vue 源码中存在一个 VNode 类，通过这个类，我们就可以实例化出不同类型的虚拟 DOM 节点")]),v._v(" "),d("p",[v._v("VNode 的类型：")]),v._v(" "),d("ol",[d("li",[v._v("注释节点")]),v._v(" "),d("li",[v._v("文本节点")]),v._v(" "),d("li",[v._v("元素节点")]),v._v(" "),d("li",[v._v("组件节点")]),v._v(" "),d("li",[v._v("函数式组件节点")]),v._v(" "),d("li",[v._v("克隆节点")])]),v._v(" "),d("p",[v._v("VNode 的作用：")]),v._v(" "),d("p",[v._v("在视图渲染之前，把写好的 template 模板先编译成 VNode 并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的 VNode 与前一次缓存下来的 VNode 进行对比，找出差异，然后有差异的 VNode 对应的真实 DOM 节点就是需要重新渲染的节点，最后根据有差异的 VNode 创建出真实的 DOM 节点再插入到视图中，最终完成一次视图更新")]),v._v(" "),d("h2",{attrs:{id:"diff-算法"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[v._v("#")]),v._v(" diff 算法")]),v._v(" "),d("p",[v._v("优化的 diff 算法时间复杂度：O(n)")]),v._v(" "),d("p",[v._v("优化的 diff 算法：深度优先算法，比较新旧节点只会在同层级进行, 不会跨层级比较。")]),v._v(" "),d("p",[v._v("Diff 算法就是 patch（打补丁）过程：")]),v._v(" "),d("ol",[d("li",[d("p",[v._v("创建节点：新的 VNode 中有而旧的 oldVNode 中没有，就在旧的 oldVNode 中创建。")])]),v._v(" "),d("li",[d("p",[v._v("删除节点：新的 VNode 中没有而旧的 oldVNode 中有，就从旧的 oldVNode 中删除。")])]),v._v(" "),d("li",[d("p",[v._v("更新节点：新的 VNode 和旧的 oldVNode 中都有，就以新的 VNode 为准，更新旧的 oldVNode。")])])]),v._v(" "),d("p",[v._v("diff 算法原理：")]),v._v(" "),d("p",[v._v("diff 过程整体遵循深度优先，同层比较的策略；")]),v._v(" "),d("p",[v._v("两个节点之间的比较会根据他们是否拥有子节点或者文本节点做不同的操作，")]),v._v(" "),d("p",[v._v("比较两组子节点是算法的重点，首先假设头尾节点可能相同，做 4 次对比尝试，")]),v._v(" "),d("p",[v._v("如果没有找到相同的节点才按照通用方式遍历查找，查找结束再按照情况处理剩下的节点，")]),v._v(" "),d("p",[v._v("借助 key 通常可以非常精确的找到相同的节点，因此整个 patch 过程会非常的高效")]),v._v(" "),d("h3",{attrs:{id:"diff-算法回答模板"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法回答模板"}},[v._v("#")]),v._v(" Diff 算法回答模板")]),v._v(" "),d("ol",[d("li",[d("p",[v._v("是什么")])]),v._v(" "),d("li",[d("p",[v._v("性能、好处：跨平台+兼容性")])]),v._v(" "),d("li",[d("p",[v._v("在什么地方使用，落地：在 patch 打补丁时，存在新旧虚拟 dom 时")])]),v._v(" "),d("li",[d("p",[v._v("怎么比较的：总体来说，深度优先+同层比较")])])]),v._v(" "),d("h3",{attrs:{id:"传统的-diff-算法"}},[d("a",{staticClass:"header-anchor",attrs:{href:"#传统的-diff-算法"}},[v._v("#")]),v._v(" 传统的 diff 算法")]),v._v(" "),d("p",[v._v("传统的 diff 算法时间复杂度：O(n³)")]),v._v(" "),d("p",[v._v("传统 Diff 算法需要找到两个树的最小更新方式，所以需要两两对比每个叶子节点是否相同，对比就需要 O(n^2)次了，再加上更新（移动、创建、删除）时需要遍历一次，所以是 O(n^3)。")])])}),[],!1,null,null,null);_.default=t.exports}}]);