(window.webpackJsonp=window.webpackJsonp||[]).push([[298],{761:function(t,e,a){"use strict";a.r(e);var r=a(24),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"三种路由模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种路由模式"}},[t._v("#")]),t._v(" 三种路由模式")]),t._v(" "),a("p",[t._v("vue-router 默认是 hash 模式")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("hash 模式")])]),t._v(" "),a("li",[a("p",[t._v("history 模式")])]),t._v(" "),a("li",[a("p",[t._v("abstract 模式")])])]),t._v(" "),a("p",[t._v("vue-router 在不支持 history 模式的浏览器 ， 会自动会退到 hash 模式。(源码是通过 fallback 进行降级处理)")]),t._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("vue-router 原理主要分成两部分，一部分是安装，另一个是实现数据监控和页面跳转。")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("安装")])])])]),t._v(" "),a("p",[t._v("通过混入 beforeCreate 实现路由的绑定和监听操作。初始化 router。调用 Vue 工具类方法 defineReactive，当 router 发生改变时，页面能及时响应更新。最后通过 registerInstance 来实现对 router-view 的挂载操作。")]),t._v(" "),a("p",[t._v("（1）混入 beforeCreate（实现路由的绑定和监听操作）和 destoryed 方法；")]),t._v(" "),a("p",[t._v("（2）全局挂载$router和$route；")]),t._v(" "),a("p",[t._v("（3）注册 router-link 和 router-view 两个组件。")]),t._v(" "),a("ul",[a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("数据监控和页面跳转")])])])]),t._v(" "),a("p",[t._v("路由更新 -> 视图。路由发生变化（hash 有 hashChange 监听方法，history 有 popstate），改变浏览器里的地址，再更新视图。采用 hash 或者 history 的路由模式，前端实现路由跳转。history 模式中，主要通过 pushstate、replaceState、go 实现，它们负责改变浏览器的路由，但是不跳转，这就实现了前端的路由，而 popstate 是监听方法，处理路由改变后，前端页面的显示问题。就是用栈来实现。")]),t._v(" "),a("h3",{attrs:{id:"_1-hash-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-hash-模式"}},[t._v("#")]),t._v(" 1. hash 模式")]),t._v(" "),a("p",[t._v('利用 URL 中的 hash("#");')]),t._v(" "),a("p",[t._v("'#' 和后面 URL 片段标识符被称为 hash， 可通过 "),a("code",[t._v("window.location.hash")]),t._v(" 属性读取.")]),t._v(" "),a("p",[t._v("hash 虽然出现在 url 中，但不会被包括在 http 请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面。")]),t._v(" "),a("p",[t._v('使用 window.addEventListener("hashchange", fun) 监听路由的变化,然后使用 transitionTo（功能是路由跳转） 方法更新视图')]),t._v(" "),a("p",[t._v("每一次改变 hash("),a("code",[t._v("window.location.hash")]),t._v(")，都会在浏览器访问历史中增加一个记录。")]),t._v(" "),a("p",[t._v('利用 hash 的以上特点，就可以来实现前端路由"更新视图但不重新请求页面"的功能了。')]),t._v(" "),a("ol",[a("li",[a("code",[t._v("HashHistory.push()")])])]),t._v(" "),a("p",[t._v("原理： 通过 "),a("code",[t._v("Vue.mixin()")]),t._v("方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在 beforeCreate 钩子中通过 "),a("code",[t._v("Vue.util.defineReactive()")]),t._v("定义了响应式的_route 属性。所谓响应式属性，即当"),a("code",[t._v("\\_route")]),t._v(" 值改变时，会自动调用 Vue 实例的"),a("code",[t._v("render()")]),t._v("方法，更新视图。")]),t._v(" "),a("p",[t._v("顺序："),a("code",[t._v("\\$router.push()--\x3eHashHistory.push()--\x3eHistory.transitionTo()--\x3eHistory.updateRoute()--\x3e{app.\\_route=route}--\x3evm.render()")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("code",[t._v("HashHistory.replace()")])])]),t._v(" "),a("p",[t._v("原理： 调用 "),a("code",[t._v("window.location.replace")]),t._v(" 方法将路由进行替换")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("监听地址栏")])]),t._v(" "),a("p",[t._v("hash 值的改变会触发 hashchange 事件")]),t._v(" "),a("p",[t._v("上面的 "),a("code",[t._v("VueRouter.push()")]),t._v("和 "),a("code",[t._v("VueRouter.replace()")]),t._v("是可以在 vue 组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在 HashHistory 中这一功能通过 setupListeners 监听 hashchange 实现：")]),t._v(" "),a("h3",{attrs:{id:"_2-history-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-history-模式"}},[t._v("#")]),t._v(" 2. history 模式")]),t._v(" "),a("p",[t._v("主要 HTML5 History API")]),t._v(" "),a("p",[t._v("使用 history.back(), history.forward()和 history.go() 方法来完成在用户历史记录中向后和向前的跳转。等操作会主动触发 popstate 事件")]),t._v(" "),a("p",[t._v("HTML5 History API 方法：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("pushState 添加历史记录条目")])]),t._v(" "),a("li",[a("p",[t._v("replaceState 修改历史记录条目")])]),t._v(" "),a("li",[a("p",[t._v("popstate 当活动的历史记录项发生变化时， popstate 事件都会被传递给 window 对象")])]),t._v(" "),a("li",[a("p",[t._v("go() 用 go() 方法载入到会话历史中的某一特定页面， 通过与当前页面相对位置来标志 (当前页面的相对位置标志为 0)")])])]),t._v(" "),a("p",[a("code",[t._v("window.history.go(-1); // 向后移动一个页面")])]),t._v(" "),a("p",[a("code",[t._v("window.history.go(1); // 向前移动一个页面")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("back() 在 history 中向后跳转")])]),t._v(" "),a("h3",{attrs:{id:"_3-abstract-模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-abstract-模式"}},[t._v("#")]),t._v(" 3. abstract 模式")]),t._v(" "),a("p",[t._v("abstract 模式没有使用浏览器 api，可以放到 node 环境或者桌面应用中。")]),t._v(" "),a("h3",{attrs:{id:"hash-模式和-history-模式区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hash-模式和-history-模式区别"}},[t._v("#")]),t._v(" hash 模式和 history 模式区别")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("url 不同： hash 带#，histary 不带#")])]),t._v(" "),a("li",[a("p",[t._v("pushState 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中")])]),t._v(" "),a("li",[a("p",[t._v("兼容性： hash 兼容 IE8 以上，history 兼容 IE10 以上 ,hash 支持低版本浏览器和 IE 浏览器，history 模式下需要支持 H5 的浏览器，使用的是 H5 的 api")])]),t._v(" "),a("li",[a("p",[t._v("底层监听的事件不一样")])])]),t._v(" "),a("p",[t._v("hash 模式： "),a("code",[t._v("window.addEventListener('hashChange', function() { // ... });")])]),t._v(" "),a("p",[t._v("history 模式："),a("code",[t._v("window.addEventListener('popstate', function() { // ... });")])]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("第三种路由模式 Abstract： 支持所有 javascript 运行模式。如果发现没有浏览器的 API，路由会自动强制进入这个模式。")])]),t._v(" "),a("h2",{attrs:{id:"三种路由守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种路由守卫"}},[t._v("#")]),t._v(" 三种路由守卫")]),t._v(" "),a("h3",{attrs:{id:"完整的导航解析流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#完整的导航解析流程"}},[t._v("#")]),t._v(" 完整的导航解析流程")]),t._v(" "),a("ul",[a("li",[t._v("导航被触发。")]),t._v(" "),a("li",[t._v("在失活的组件里调用 beforeRouteLeave 守卫。")]),t._v(" "),a("li",[t._v("调用全局的 beforeEach 守卫。")]),t._v(" "),a("li",[t._v("在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。")]),t._v(" "),a("li",[t._v("在路由配置里调用 beforeEnter。")]),t._v(" "),a("li",[t._v("解析异步路由组件。")]),t._v(" "),a("li",[t._v("在被激活的组件里调用 beforeRouteEnter。")]),t._v(" "),a("li",[t._v("调用全局的 beforeResolve 守卫 (2.5+)。")]),t._v(" "),a("li",[t._v("导航被确认。")]),t._v(" "),a("li",[t._v("调用全局的 afterEach 钩子。")]),t._v(" "),a("li",[t._v("触发 DOM 更新。")]),t._v(" "),a("li",[t._v("调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。")])]),t._v(" "),a("h3",{attrs:{id:"全局路由守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局路由守卫"}},[t._v("#")]),t._v(" 全局路由守卫")]),t._v(" "),a("ol",[a("li",[t._v("全局前置守卫 beforeEach")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" router "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VueRouter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nrouter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("beforeEach")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("to"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("参数：")]),t._v(" "),a("p",[t._v("to: Route: 即将要进入的目标 路由对象")]),t._v(" "),a("p",[t._v("from: Route: 当前导航正要离开的路由")]),t._v(" "),a("p",[t._v("next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("全局解析守卫 beforeResolve")])]),t._v(" "),a("p",[t._v("在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("全局后置钩子 afterEach")])]),t._v(" "),a("h3",{attrs:{id:"路由独享守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由独享守卫"}},[t._v("#")]),t._v(" 路由独享守卫")]),t._v(" "),a("ol",[a("li",[t._v("beforeEnter")])]),t._v(" "),a("h3",{attrs:{id:"组件内路由守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件内路由守卫"}},[t._v("#")]),t._v(" 组件内路由守卫")]),t._v(" "),a("ol",[a("li",[t._v("beforeRouteEnter")])]),t._v(" "),a("p",[t._v("在渲染该组件的对应路由被 confirm 前调用")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("beforeRouteUpdate")])]),t._v(" "),a("p",[t._v("在当前路由改变，但是该组件被复用时调用")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("beforeRouteLeave")])]),t._v(" "),a("p",[t._v("导航离开该组件的对应路由时调用")]),t._v(" "),a("h2",{attrs:{id:"其它问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它问题"}},[t._v("#")]),t._v(" 其它问题")]),t._v(" "),a("h3",{attrs:{id:"route-和-router-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#route-和-router-有什么区别"}},[t._v("#")]),t._v(" route 和 router 有什么区别？")]),t._v(" "),a("h4",{attrs:{id:"route-是-路由信息对象-是正在跳转的这个路由的局部对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#route-是-路由信息对象-是正在跳转的这个路由的局部对象"}},[t._v("#")]),t._v(" $route 是“路由信息对象”（是正在跳转的这个路由的局部对象），")]),t._v(" "),a("p",[t._v("包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。")]),t._v(" "),a("ul",[a("li",[t._v("$route.path\n"),a("blockquote",[a("p",[t._v('字符串，等于当前路由对象的路径，会被解析为绝对路径，如 "/home/news" 。')])])]),t._v(" "),a("li",[t._v("$route.params\n"),a("blockquote",[a("p",[t._v("对象，包含路由中的动态片段和全匹配片段的键值对")])])]),t._v(" "),a("li",[t._v("$route.query\n"),a("blockquote",[a("p",[t._v("对象，包含路由中查询参数的键值对。例如，对于 /home/news/detail/01?favorite=yes ，会得到$route.query.favorite == 'yes' 。")])])]),t._v(" "),a("li",[t._v("$route.router\n"),a("blockquote",[a("p",[t._v("路由规则所属的路由器（以及其所属的组件）。")])])]),t._v(" "),a("li",[t._v("$route.matched\n"),a("blockquote",[a("p",[t._v("数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。")])])]),t._v(" "),a("li",[t._v("$route.name")])]),t._v(" "),a("blockquote",[a("p",[t._v("当前路径的名字，如果没有使用具名路径，则名字为空。")])]),t._v(" "),a("h4",{attrs:{id:"router-是-路由实例-对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#router-是-路由实例-对象"}},[t._v("#")]),t._v(" $router 是“路由实例”对象")]),t._v(" "),a("p",[t._v("包括了路由的跳转方法，钩子函数,是 VueRouter 的一个对象，通过 Vue.use(VueRouter)和 VueRouter 构造函数得到一个 router 的实例对象")])])}),[],!1,null,null,null);e.default=s.exports}}]);