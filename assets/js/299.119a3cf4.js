(window.webpackJsonp=window.webpackJsonp||[]).push([[299],{842:function(s,t,e){"use strict";e.r(t);var a=e(14),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h2",{attrs:{id:"class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[s._v("#")]),s._v(" class")]),s._v(" "),e("p",[s._v("class 为 构造函数的语法糖，即 class 的本质是 构造函数。class 的继承 extends 本质 为构造函数的原型链的继承。")]),s._v(" "),e("h3",{attrs:{id:"super"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#super"}},[s._v("#")]),s._v(" super")]),s._v(" "),e("p",[s._v("既可以当作函数使用，也可以当作对象使用")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。")])]),s._v(" "),e("li",[e("p",[s._v("super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。")])])]),s._v(" "),e("h3",{attrs:{id:"es6-extends-实现继承原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-extends-实现继承原理"}},[s._v("#")]),s._v(" ES6 extends 实现继承原理")]),s._v(" "),e("p",[s._v("extends 的继承通过两种方式完成了三类值的继承")]),s._v(" "),e("ol",[e("li",[e("p",[s._v("构造函数设置的属性通过复制完成继承")])]),s._v(" "),e("li",[e("p",[s._v("实例方法通过实例原型之间的原型链完成继承")])]),s._v(" "),e("li",[e("p",[s._v("构造函数的静态方法通过构造函数之间的原型链完成继承")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);