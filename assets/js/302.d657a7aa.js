(window.webpackJsonp=window.webpackJsonp||[]).push([[302],{838:function(t,a,s){"use strict";s.r(a);var e=s(14),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"let-和-const-命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const-命令"}},[t._v("#")]),t._v(" let 和 const 命令")]),t._v(" "),s("p",[t._v("顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象")]),t._v(" "),s("h3",{attrs:{id:"变量提升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[t._v("#")]),t._v(" 变量提升")]),t._v(" "),s("p",[t._v("var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined")]),t._v(" "),s("p",[t._v("ES6 规定暂时性死区和 let、const 语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量")]),t._v(" "),s("h3",{attrs:{id:"暂时性死区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#暂时性死区"}},[t._v("#")]),t._v(" 暂时性死区")]),t._v(" "),s("p",[t._v("暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。")]),t._v(" "),s("p",[t._v("只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。")]),t._v(" "),s("p",[t._v("ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。")]),t._v(" "),s("h3",{attrs:{id:"块状作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#块状作用域"}},[t._v("#")]),t._v(" 块状作用域")]),t._v(" "),s("p",[t._v("内层作用域可以定义外层作用域的同名变量。")]),t._v(" "),s("h3",{attrs:{id:"let"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[t._v("#")]),t._v(" let")]),t._v(" "),s("p",[t._v("不允许重复声明：let 不允许在相同作用域内，重复声明同一个变量。")]),t._v(" "),s("h3",{attrs:{id:"const"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[t._v("#")]),t._v(" const")]),t._v(" "),s("h3",{attrs:{id:"es6-声明变量的六种方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6-声明变量的六种方法"}},[t._v("#")]),t._v(" ES6 声明变量的六种方法")]),t._v(" "),s("p",[t._v("var 命令和 function 命令。")]),t._v(" "),s("p",[t._v("let 和 const 命令，")]),t._v(" "),s("p",[t._v("import 命令和 class 命令。")])])}),[],!1,null,null,null);a.default=r.exports}}]);