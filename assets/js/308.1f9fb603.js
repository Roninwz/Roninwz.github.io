(window.webpackJsonp=window.webpackJsonp||[]).push([[308],{774:function(t,e,a){"use strict";a.r(e);var s=a(24),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),a("p",[t._v("包裹动态组件时，会缓存不活动的组件实例")]),t._v(" "),a("h3",{attrs:{id:"两个钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#两个钩子"}},[t._v("#")]),t._v(" 两个钩子")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("activated 被 keep-alive 缓存的组件激活时调用。")])]),t._v(" "),a("li",[a("p",[t._v("deactivated 被 keep-alive 缓存的组件停用时调用。")])])]),t._v(" "),a("h3",{attrs:{id:"三个属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三个属性"}},[t._v("#")]),t._v(" 三个属性")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("include - 字符串或正则表达式。只有名称匹配的组件会被缓存。")])]),t._v(" "),a("li",[a("p",[t._v("exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。")])]),t._v(" "),a("li",[a("p",[t._v("max - 数字。最多可以缓存多少组件实例")])])]),t._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("使用了 LRU 的缓存策略。(Least Recently Used 最近最少使用)")]),t._v(" "),a("p",[t._v("LRU 的核心思想是如果数据最近被访问过，那么将来被访问的几率也更高，优先淘汰最近没有被访问到的数据")]),t._v(" "),a("p",[t._v("算法：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("this.keys 数组用来存储数据")])]),t._v(" "),a("li",[a("p",[t._v("将新数据从尾部插入到 this.keys 中")])]),t._v(" "),a("li",[a("p",[t._v("每当缓存命中（即缓存数据被访问），则将数据移到 this.keys 的尾部；")])]),t._v(" "),a("li",[a("p",[t._v("当 this.keys 满的时候，将头部的数据丢弃；")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);