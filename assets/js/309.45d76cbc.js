(window.webpackJsonp=window.webpackJsonp||[]).push([[309],{850:function(t,e,v){"use strict";v.r(e);var r=v(14),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"typescript"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" typescript")]),t._v(" "),v("p",[t._v("TS 中对于被标记为 any 类型的变量，是没有进行类型检查而直接通过编译阶段的检查。")]),t._v(" "),v("h3",{attrs:{id:"泛型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),v("p",[t._v("泛型是一种创建可复用代码组件的工具。这种组件不只能被一种类型使用，而是能被多种类型复用。类似于参数的作用，泛型是一种用以增强类（classes）、类型（types）和接口（interfaces）能力的非常可靠的手段。这样，我们开发者，就可以轻松地将那些可复用的代码组件，适用于各种输入。")]),t._v(" "),v("h3",{attrs:{id:"接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),v("p",[t._v("适用场景：从服务器端获取或者业务场景中模拟的数据，这些数据通常是不会经常变化和调整的，这些数据可能仅仅只表示某些状态，或者是 UI 上的文本。提倡使用 interface 去定义")]),t._v(" "),v("h2",{attrs:{id:"ts-问题汇总"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#ts-问题汇总"}},[t._v("#")]),t._v(" ts 问题汇总")]),t._v(" "),v("h3",{attrs:{id:"typescript-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript-优缺点"}},[t._v("#")]),t._v(" typescript 优缺点")]),t._v(" "),v("p",[t._v("优点：")]),t._v(" "),v("ol",[v("li",[t._v("TypeScript 增加了代码的可读性和可维护性")])]),t._v(" "),v("p",[t._v("（1）类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了")]),t._v(" "),v("p",[t._v("（2）可以在编译阶段就发现大部分错误，这总比在运行时候出错好")]),t._v(" "),v("p",[t._v("（3）增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("TypeScript 非常包容")])]),t._v(" "),v("p",[t._v("（1）TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可")]),t._v(" "),v("p",[t._v("（2）即使不显式的定义类型，也能够自动做出类型推论")]),t._v(" "),v("p",[t._v("（3）可以定义从简单到复杂的几乎一切类型")]),t._v(" "),v("p",[t._v("（4）即使 TypeScript 编译报错，也可以生成 JavaScript 文件")]),t._v(" "),v("p",[t._v("（5）兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("TypeScript 拥有活跃的社区")])]),t._v(" "),v("p",[t._v("缺点：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念")])]),t._v(" "),v("li",[v("p",[t._v("短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本")])])]),t._v(" "),v("h3",{attrs:{id:"typescript-和-javascript-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript-和-javascript-区别"}},[t._v("#")]),t._v(" typescript 和 javascript 区别")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，")])]),t._v(" "),v("li",[v("p",[t._v("TypeScript 通过类型注解提供编译时的静态类型检查。")])]),t._v(" "),v("li",[v("p",[t._v("后缀不同：TypeScript 文件的后缀名 .ts （.ts，.tsx），JavaScript 文件是 .js")])]),t._v(" "),v("li",[v("p",[t._v("语言类型不同：TypeScript 是面向对象编程语言，JavaScript 是脚本语言")])])]),t._v(" "),v("h3",{attrs:{id:"any、never、unknown-和-void-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#any、never、unknown-和-void-区别"}},[t._v("#")]),t._v(" any、never、unknown 和 void 区别")]),t._v(" "),v("ol",[v("li",[t._v("定义")])]),t._v(" "),v("p",[t._v("any ：用于描述任意类型的变量，不作任何约束，编译时会跳过对其的类型检查")]),t._v(" "),v("p",[t._v("unknown ：表示未知类型，即写代码的时候还不知道具体会是怎样的数据类型")]),t._v(" "),v("p",[t._v("never ：永不存在的值的类型，常用于表示永不能执行到终点的函数返回值，例如抛出异常或函数中执行无限循环的代码（死循环）的函数返回值类型")]),t._v(" "),v("p",[t._v("void ：表示无任何类型，没有类型，例如没有返回值的函数的返回值类型")]),t._v(" "),v("p",[t._v("any 与 unknown 的区别：")]),t._v(" "),v("p",[t._v("(1) unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行断言或守卫")]),t._v(" "),v("p",[t._v("(2) any 类型导致问题太多了，如类型污染，使用不存在的属性或方法而不报错等，而且不不方便后期维护，所以，建议能不用 any 就不用 any，但是如果声明时并不确定具体的类型，则可以使用 unknown 代替，在使用时用类型断言或类型守卫进行类型收缩")]),t._v(" "),v("p",[t._v("never 与 void 的区别：")]),t._v(" "),v("p",[t._v("(1) 用于函数时， never 表示函数用于执行不到返回值那一步（抛出异常或死循环）的返回值类型，即永不存在的值的类型，而 void 则表示没有返回值，不返回或返回 undefined")]),t._v(" "),v("p",[t._v("参考："),v("a",{attrs:{href:"https://jishuin.proginn.com/p/763bfbd657b8",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://jishuin.proginn.com/p/763bfbd657b8"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"type-和-interface-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#type-和-interface-的区别"}},[t._v("#")]),t._v(" type 和 interface 的区别")]),t._v(" "),v("p",[t._v("在 ts 中，定义类型由两种方式：接口（interface）和类型别名（type alias）")]),t._v(" "),v("p",[t._v("相同点：")]),t._v(" "),v("ol",[v("li",[t._v("都可以描述一个对象或者函数")])]),t._v(" "),v("p",[t._v("区别：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("interface 只能定义对象类型，type 声明的方式可以定义组合类型，交叉类型和原始类型")])]),t._v(" "),v("li",[v("p",[t._v("interface 方式可以实现接口的 extends/implements，而 type 不行")])]),t._v(" "),v("li",[v("p",[t._v("interface 可以声明合并，但是 type 不行")])])]),t._v(" "),v("blockquote",[v("p",[t._v("参考："),v("a",{attrs:{href:"https://github.com/sisterAn/blog/issues/126",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/sisterAn/blog/issues/126"),v("OutboundLink")],1)])]),t._v(" "),v("hr"),t._v(" "),v("p",[t._v("Typescript 打包编译原理")])])}),[],!1,null,null,null);e.default=a.exports}}]);