(window.webpackJsonp=window.webpackJsonp||[]).push([[310],{765:function(e,t,s){"use strict";s.r(t);var v=s(20),a=Object(v.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"js-基础面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-基础面试题"}},[e._v("#")]),e._v(" js 基础面试题")]),e._v(" "),s("h3",{attrs:{id:"_1-基本数据类型和引用类型的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本数据类型和引用类型的区别"}},[e._v("#")]),e._v(" 1. 基本数据类型和引用类型的区别")]),e._v(" "),s("ul",[s("li",[e._v("1、基本类型的值是不可变得，引用类型的值是可变的")]),e._v(" "),s("li",[e._v("2、基本类型的比较是值的比较，引用类型的比较是引用地址的比较")]),e._v(" "),s("li",[e._v("3、基本类型的变量是存放在栈区的（栈区指内存里的栈内存），引用类型的值是同时保存在栈内存和堆内存中的对象")])]),e._v(" "),s("h3",{attrs:{id:"_2-var、let、const-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-var、let、const-区别"}},[e._v("#")]),e._v(" 2. var、let、const 区别")]),e._v(" "),s("ol",[s("li",[e._v("var 存在变量提升")])]),e._v(" "),s("p",[e._v("var 关键字声明的变量，都会被提升到该作用域的最顶部")]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("let 和 const 产生暂时性死区")])]),e._v(" "),s("p",[e._v("如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成封闭作用域。凡是在声明之前就使用这些变量，就会报错。")]),e._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[e._v("var 允许重复声明")])]),e._v(" "),s("p",[e._v("var 是允许在相同作用域内重复声明同一个变量的，而 let 与 const 不允许这一现象")]),e._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("p",[e._v("let 和 const 只在声明所在的块级作用域内有效")])]),e._v(" "),s("li",[s("p",[e._v("const 定义的变量不可以修改，而且必须初始化，var 定义的变量可以修改，如果不初始化会输出 undefined，不会报错")])]),e._v(" "),s("li",[s("p",[e._v("使用 var 声明的全局变量，会被 JS 自动添加在全局对象 window 上，但 let 和 const 不会")])])]),e._v(" "),s("p",[e._v("正确使用：")]),e._v(" "),s("p",[e._v("在开发的时候，声明变量我们应该少使用 var，避免产生不必要的全局变量。当需要改变变量的值时声明用 let，对于需要写保护的变量或定义常量使用 const。")]),e._v(" "),s("h3",{attrs:{id:"_1-defer-async-的区别及应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-defer-async-的区别及应用场景"}},[e._v("#")]),e._v(" 1. defer & async 的区别及应用场景")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("没有 defer 或 async 属性，浏览器会立即加载并执行相应的脚本。同步，不等待，此举会阻塞后续文档的加载；")])]),e._v(" "),s("li",[s("p",[e._v("async: 表示后续文档的加载和渲染与 js 脚本的加载和执行是异步执行的，但是标记为 async 的脚本并不保证按照指定它们的先后顺序执行，也就是说后面的 js 脚本可能先于之前的 Js 脚本执行；")])]),e._v(" "),s("li",[s("p",[e._v("defer: 加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是异步进行的，js 脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded 事件触发执行之前。")])]),e._v(" "),s("li",[s("p",[e._v("当 script 同时有 async 和 defer 属性时，执行效果和 async 一致。")])])]),e._v(" "),s("p",[e._v("适用场景：")]),e._v(" "),s("ol",[s("li",[e._v("async 适合没有相互依赖关系的多个外部脚本使用")])]),e._v(" "),s("h4",{attrs:{id:"追问-为什么加载同步-script-标签中的内容会阻塞文档渲染"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#追问-为什么加载同步-script-标签中的内容会阻塞文档渲染"}},[e._v("#")]),e._v(" 追问：为什么加载同步 script 标签中的内容会阻塞文档渲染？")]),e._v(" "),s("p",[e._v("JS 会对 DOM 节点进行操作，浏览器无法预测未来的 DOM 节点的具体内容，为了防止无效操作，节省资源，只能阻塞 DOM 树的构建。")]),e._v(" "),s("h3",{attrs:{id:"_7-mouseenter、mouseleave、mouseover-和-mouseout-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-mouseenter、mouseleave、mouseover-和-mouseout-的区别"}},[e._v("#")]),e._v(" 7.mouseenter、mouseleave、mouseover 和 mouseout 的区别")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("mouseover 和 mouseout 会冒泡，在父元素和其子元素都可以触发，当鼠标穿过一个元素时，触发次数得依子元素数量而言。")])]),e._v(" "),s("li",[s("p",[e._v("mouseenter 和 mouseleave 只在父元素触发，当鼠标穿过一个元素时，只会触发一次。")])]),e._v(" "),s("li",[s("p",[e._v("mouseover 和 mouseout 比 mouseenter 和 mouseleave 先触发")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);