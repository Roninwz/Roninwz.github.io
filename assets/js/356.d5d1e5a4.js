(window.webpackJsonp=window.webpackJsonp||[]).push([[356],{887:function(v,_,t){"use strict";t.r(_);var f=t(14),d=Object(f.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"diff-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[v._v("#")]),v._v(" diff 算法")]),v._v(" "),t("p",[v._v("优化的 diff 算法时间复杂度：O(n)")]),v._v(" "),t("p",[v._v("优化的 diff 算法：深度优先算法，比较新旧节点只会在同层级进行, 不会跨层级比较。")]),v._v(" "),t("p",[v._v("Diff 算法就是 patch（打补丁）过程：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("创建节点：新的 VNode 中有而旧的 oldVNode 中没有，就在旧的 oldVNode 中创建。")])]),v._v(" "),t("li",[t("p",[v._v("删除节点：新的 VNode 中没有而旧的 oldVNode 中有，就从旧的 oldVNode 中删除。")])]),v._v(" "),t("li",[t("p",[v._v("更新节点：新的 VNode 和旧的 oldVNode 中都有，就以新的 VNode 为准，更新旧的 oldVNode。")])])]),v._v(" "),t("p",[v._v("diff 算法原理：")]),v._v(" "),t("p",[v._v("diff 过程整体遵循深度优先，同层比较的策略；")]),v._v(" "),t("p",[v._v("两个节点之间的比较会根据他们是否拥有子节点或者文本节点做不同的操作，")]),v._v(" "),t("p",[v._v("比较两组子节点是算法的重点，首先假设头尾节点可能相同，做 4 次对比尝试，")]),v._v(" "),t("p",[v._v("如果没有找到相同的节点才按照通用方式遍历查找，查找结束再按照情况处理剩下的节点，")]),v._v(" "),t("p",[v._v("借助 key 通常可以非常精确的找到相同的节点，因此整个 patch 过程会非常的高效")]),v._v(" "),t("h3",{attrs:{id:"diff-对比原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff-对比原则"}},[v._v("#")]),v._v(" diff 对比原则")]),v._v(" "),t("p",[v._v("对比原则 1：逐层对比")]),v._v(" "),t("p",[v._v("第一层不一样，直接替换；第一层一样，进行第二层对比……")]),v._v(" "),t("p",[v._v("对比原则 2：从两边向中间")]),v._v(" "),t("p",[v._v("新旧元素的子节点首尾两两对比，有相同的，则放到新元素对应的位置；不相同就向中间移动，再次对比")]),v._v(" "),t("h3",{attrs:{id:"diff-算法回答模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法回答模板"}},[v._v("#")]),v._v(" Diff 算法回答模板")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("是什么")])]),v._v(" "),t("li",[t("p",[v._v("性能、好处：跨平台+兼容性")])]),v._v(" "),t("li",[t("p",[v._v("在什么地方使用，落地：在 patch 打补丁时，存在新旧虚拟 dom 时")])]),v._v(" "),t("li",[t("p",[v._v("怎么比较的：总体来说，深度优先+同层比较")])])]),v._v(" "),t("h3",{attrs:{id:"传统的-diff-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传统的-diff-算法"}},[v._v("#")]),v._v(" 传统的 diff 算法")]),v._v(" "),t("p",[v._v("传统的 diff 算法时间复杂度：O(n³)")]),v._v(" "),t("p",[v._v("传统 Diff 算法需要找到两个树的最小更新方式，所以需要两两对比每个叶子节点是否相同，对比就需要 O(n^2)次了，再加上更新（移动、创建、删除）时需要遍历一次，所以是 O(n^3)。")])])}),[],!1,null,null,null);_.default=d.exports}}]);