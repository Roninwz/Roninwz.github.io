(window.webpackJsonp=window.webpackJsonp||[]).push([[373],{918:function(t,e,v){"use strict";v.r(e);var _=v(14),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"vue3-新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-新特性"}},[t._v("#")]),t._v(" vue3 新特性")]),t._v(" "),v("h3",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("选项式 API")]),t._v(" "),v("th",[t._v("Hook inside setup")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("beforeCreate")]),t._v(" "),v("td",[t._v("Not needed")])]),t._v(" "),v("tr",[v("td",[t._v("created")]),t._v(" "),v("td",[t._v("Not needed")])]),t._v(" "),v("tr",[v("td",[t._v("beforeMount")]),t._v(" "),v("td",[t._v("onBeforeMount")])]),t._v(" "),v("tr",[v("td",[t._v("mounted")]),t._v(" "),v("td",[t._v("onMounted")])]),t._v(" "),v("tr",[v("td",[t._v("beforeUpdate")]),t._v(" "),v("td",[t._v("onBeforeUpdate")])]),t._v(" "),v("tr",[v("td",[t._v("updated")]),t._v(" "),v("td",[t._v("onUpdated")])]),t._v(" "),v("tr",[v("td",[t._v("beforeUnmount")]),t._v(" "),v("td",[t._v("onBeforeUnmount")])]),t._v(" "),v("tr",[v("td",[t._v("unmounted")]),t._v(" "),v("td",[t._v("onUnmounted")])]),t._v(" "),v("tr",[v("td",[t._v("errorCaptured")]),t._v(" "),v("td",[t._v("onErrorCaptured")])]),t._v(" "),v("tr",[v("td",[t._v("renderTracked")]),t._v(" "),v("td",[t._v("onRenderTracked")])]),t._v(" "),v("tr",[v("td",[t._v("renderTriggered")]),t._v(" "),v("td",[t._v("onRenderTriggered")])]),t._v(" "),v("tr",[v("td",[t._v("activated")]),t._v(" "),v("td",[t._v("onActivated")])]),t._v(" "),v("tr",[v("td",[t._v("deactivated")]),t._v(" "),v("td",[t._v("onDeactivated")])])])]),t._v(" "),v("h3",{attrs:{id:"组合式-api-composition-api"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组合式-api-composition-api"}},[t._v("#")]),t._v(" 组合式 API (Composition API)")]),t._v(" "),v("p",[t._v("优点：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("更好的逻辑复用与代码组织，暴露给模板的 property 来源十分清晰，因为它们都是被组合逻辑函数返回的值。")])]),t._v(" "),v("li",[v("p",[t._v("不存在命名空间冲突，可以通过解构任意命名")])]),t._v(" "),v("li",[v("p",[t._v("不再需要仅为逻辑复用而创建组件实例")])]),t._v(" "),v("li",[v("p",[t._v("仅依赖它的参数和 Vue 全局导出的 API，而不是依赖其微妙的 this 上下文")])])]),t._v(" "),v("p",[t._v("参考："),v("a",{attrs:{href:"https://segmentfault.com/a/1190000023016699",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://segmentfault.com/a/1190000023016699"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("对比 vue2 的混入：")]),t._v(" "),v("p",[t._v("优点：mixin 可以根据逻辑关注点进行组织代码")]),t._v(" "),v("p",[t._v("缺点：")]),t._v(" "),v("ol",[v("li",[t._v("它们容易发生冲突，最终可能导致属性名称冲突。")]),t._v(" "),v("li",[t._v("不清楚混合元素如何作用，渲染上下文中暴露的 property 来源不清晰。例如在阅读一个运用了多个 mixin 的模板时，很难看出某个 property 是从哪一个 mixin 中注入的。")]),t._v(" "),v("li",[t._v("混合后的组件属性不方便在其他组件中重用。")])]),t._v(" "),v("h3",{attrs:{id:"proxy-和-object-defineproperty-的对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#proxy-和-object-defineproperty-的对比"}},[t._v("#")]),t._v(" Proxy 和 Object.defineProperty 的对比")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("Proxy 是直接代理对象；而 Object.defineProperty 只能劫持对象的属性，")])]),t._v(" "),v("li",[v("p",[t._v("Proxy 能监听对象的新增和删除操作；Object.defineProperty 不能监听对象的新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。")])]),t._v(" "),v("li",[v("p",[t._v("Proxy 可以直接监听数组的变化；Object.defineProperty 本身是有监控数组下标变化的能力的，只是在 Vue 的实现中，从性能/体验的性价比考虑")])]),t._v(" "),v("li",[v("p",[t._v("Proxy 支持 13 种拦截操作，不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的。")])]),t._v(" "),v("li",[v("p",[t._v("Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的；而 Object.defineProperty 只能遍历对象属性直接修改;")])]),t._v(" "),v("li",[v("p",[t._v("Proxy 兼容性差；Object.defineProperty 兼容性好，支持 IE9，")])]),t._v(" "),v("li",[v("p",[t._v("Proxy 有性能问题但是有新标准性能红利，从长远来看，JS 引擎会继续优化 Proxy")])])]),t._v(" "),v("h3",{attrs:{id:"tree-shaking-的支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-的支持"}},[t._v("#")]),t._v(" Tree-Shaking 的支持")]),t._v(" "),v("p",[t._v("Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 Dead code elimination")]),t._v(" "),v("p",[t._v("Tree shaking 是基于 ES6 模板语法（import 与 exports），主要是借助 ES6 模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量")]),t._v(" "),v("p",[t._v("Tree shaking 无非就是做了两件事：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("编译阶段利用 ES6 Module 判断哪些模块已经加载")])]),t._v(" "),v("li",[v("p",[t._v("判断那些模块和变量未被使用或者引用，进而删除对应代码")])])]),t._v(" "),v("p",[t._v("Tree-Shaking 原理："),v("a",{attrs:{href:"https://juejin.cn/post/6844903544756109319",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.cn/post/6844903544756109319"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"teleport-任意传送门"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#teleport-任意传送门"}},[t._v("#")]),t._v(" Teleport 任意传送门")]),t._v(" "),v("p",[t._v("Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术")]),t._v(" "),v("p",[t._v("适用场景：像 modals,toast 等这样的元素，很多情况下，我们将它完全的和我们的 Vue 应用的 DOM 完全剥离，管理起来反而会方便容易很多")]),t._v(" "),v("h3",{attrs:{id:"虚拟-dom-的优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的优化"}},[t._v("#")]),t._v(" 虚拟 DOM 的优化")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://www.pianshen.com/article/16291732261/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.pianshen.com/article/16291732261/"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"diff-算法的优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法的优化"}},[t._v("#")]),t._v(" diff 算法的优化")]),t._v(" "),v("ol",[v("li",[t._v("静态标记")])]),t._v(" "),v("p",[t._v("vue2 对比是进行全量的比较：在 Vue2.0 当中，当数据发生变化，它就会新生成一个 DOM 树，并和之前的 DOM 树进行比较，找到不同的节点然后更新。但这比较的过程是全量的比较")]),t._v(" "),v("p",[t._v("Vue3.0 对于不参与更新的元素，做静态标记并提示，只会被创建一次，在渲染时直接复用")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("静态提升")])]),t._v(" "),v("p",[t._v("Vue3 中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用，这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("对比过程")])]),t._v(" "),v("p",[t._v("去除相同前置和后置元素")]),t._v(" "),v("p",[t._v("vue3 diff 对比过程：")]),t._v(" "),v("p",[t._v("（1） 头和头比：先进行头和头比，发现不同就结束循环")]),t._v(" "),v("p",[t._v("（2） 尾和尾比：再进行尾和尾比，发现不同就结束循环")]),t._v(" "),v("p",[t._v("（3） 基于最长递增子序列(贪心+二分查找)进行移动/添加/删除")]),t._v(" "),v("p",[t._v("使用最长递增子序列可以最大程度的减少 DOM 的移动，达到最少的 DOM 操作")]),t._v(" "),v("p",[t._v("为什么最长递增子序列就可以保证移动次数最少呢？")]),t._v(" "),v("p",[t._v("因为在位置数组中递增就能保证在旧数组中的相对位置的有序性，从而不需要移动，因此递增子序列的最长可以保证移动次数的最少")]),t._v(" "),v("p",[t._v("时间复杂度：贪心算法的时间复杂度是 O(n)，二分查找的时间复杂度是 O(logn)，总的时间复杂度 O(nlogn)")]),t._v(" "),v("h3",{attrs:{id:"typescript-支持"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript-支持"}},[t._v("#")]),t._v(" TypeScript 支持")]),t._v(" "),v("h3",{attrs:{id:"其它"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[t._v("#")]),t._v(" 其它")]),t._v(" "),v("ol",[v("li",[t._v("片段")])]),t._v(" "),v("p",[t._v("在 2.x 中，由于不支持多根节点组件")]),t._v(" "),v("p",[t._v("在 3.x 中，组件可以包含多个根节点")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("p",[t._v("去除了过滤器，建议用计算属性代替")])]),t._v(" "),v("li",[v("p",[t._v("修改了 v-if 和 v-for 的优先级，vue3 中 v-if 优先级高")])])]),t._v(" "),v("h2",{attrs:{id:"vue3-更小更快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-更小更快"}},[t._v("#")]),t._v(" vue3 更小更快")]),t._v(" "),v("h3",{attrs:{id:"更快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更快"}},[t._v("#")]),t._v(" 更快")]),t._v(" "),v("p",[t._v("Virtual DOM 完全重写，mounting & patching 提速 100% ；")]),t._v(" "),v("p",[t._v("更多编译时（compile-time）提醒以减少 runtime 开销；")]),t._v(" "),v("p",[t._v("基于 Proxy 观察者机制以满足全语言覆盖及更好的性能；")]),t._v(" "),v("p",[t._v("放弃 Object.defineProperty ，使用更快的原生 Proxy ；")]),t._v(" "),v("p",[t._v("组件实例初始化速度提高 100％ ；")]),t._v(" "),v("p",[t._v("提速一倍/内存使用降低一半。")]),t._v(" "),v("h3",{attrs:{id:"更小"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更小"}},[t._v("#")]),t._v(" 更小")]),t._v(" "),v("p",[t._v("Tree-shaking 更友好；")]),t._v(" "),v("p",[t._v("新的 core runtime: ~10kb gzipped")]),t._v(" "),v("h3",{attrs:{id:"更易维护"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更易维护"}},[t._v("#")]),t._v(" 更易维护")]),t._v(" "),v("p",[t._v("Flow -> TypeScript")]),t._v(" "),v("p",[t._v("Decoupled Packages（解耦包）")]),t._v(" "),v("p",[t._v("编译器重写")]),t._v(" "),v("h3",{attrs:{id:"更易于原生"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#更易于原生"}},[t._v("#")]),t._v(" 更易于原生")]),t._v(" "),v("p",[t._v("自定义 Renderer API")]),t._v(" "),v("h2",{attrs:{id:"vue3-性能提升"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-性能提升"}},[t._v("#")]),t._v(" vue3 性能提升")]),t._v(" "),v("h3",{attrs:{id:"_1-编译阶段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-编译阶段"}},[t._v("#")]),t._v(" 1.编译阶段")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("diff 算法优化")])]),t._v(" "),v("li",[v("p",[t._v("静态提升")])]),t._v(" "),v("li",[v("p",[t._v("事件监听缓存")])]),t._v(" "),v("li",[v("p",[t._v("SSR 优化")])])]),t._v(" "),v("h3",{attrs:{id:"_2-源码体积"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-源码体积"}},[t._v("#")]),t._v(" 2.源码体积")]),t._v(" "),v("p",[t._v("相比 Vue2，Vue3 整体体积变小了，除了移出一些不常用的 API，再重要的是 Tree shanking")]),t._v(" "),v("p",[t._v("任何一个函数，如 ref、reavtived、computed 等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小")]),t._v(" "),v("h3",{attrs:{id:"_3-响应式系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-响应式系统"}},[t._v("#")]),t._v(" 3.响应式系统")]),t._v(" "),v("p",[t._v("vue2 中采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加 getter 和 setter，实现响应式")]),t._v(" "),v("p",[t._v("vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听，所以不需要深度遍历")])])}),[],!1,null,null,null);e.default=r.exports}}]);