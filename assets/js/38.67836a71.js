(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{538:function(e,t,r){e.exports=r.p+"assets/img/template_render.f0570125.png"},931:function(e,t,r){"use strict";r.r(t);var a=r(14),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"vue-模板编译"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-模板编译"}},[e._v("#")]),e._v(" vue 模板编译")]),e._v(" "),a("h3",{attrs:{id:"整体渲染流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#整体渲染流程"}},[e._v("#")]),e._v(" 整体渲染流程")]),e._v(" "),a("p",[e._v("所谓渲染流程，就是把用户写的类似于原生 HTML 的模板经过一系列处理最终反应到视图中称之为整个渲染流程。这个流程在上文中其实已经说到了，下面我们以流程图的形式宏观的了解一下")]),e._v(" "),a("p",[a("img",{attrs:{src:r(538),alt:"image"}})]),e._v(" "),a("h3",{attrs:{id:"模板编译具体流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板编译具体流程"}},[e._v("#")]),e._v(" 模板编译具体流程")]),e._v(" "),a("p",[e._v("具体流程可大致分为三个阶段：")]),e._v(" "),a("ol",[a("li",[e._v("模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树 AST；解析器——源码路径："),a("code",[e._v("src/compiler/parser/index.js")])])]),e._v(" "),a("p",[e._v("根据解析内容的不同分为 HTML 解析器，文本解析器和过滤器解析器")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[e._v("优化阶段：遍历 AST，找出其中的静态节点，并打上标记，方便在页面重渲染的时候进行 diff 比较时，直接跳过这一些静态节点，优化 runtime 的性能；优化器——源码路径："),a("code",[e._v("src/compiler/optimizer.js")])])]),e._v(" "),a("li",[a("p",[e._v("代码生成阶段：将 AST 转换成 render 渲染函数；代码生成器——源码路径："),a("code",[e._v("src/compiler/codegen/index.js")])])])]),e._v(" "),a("h2",{attrs:{id:"render-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-函数"}},[e._v("#")]),e._v(" render 函数")]),e._v(" "),a("h3",{attrs:{id:"render-参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-参数"}},[e._v("#")]),e._v(" render 参数")]),e._v(" "),a("ol",[a("li",[e._v("第一个参数 createElement 函数")])]),e._v(" "),a("p",[e._v("createElement 第一个参数是必填的，可以是 String | Object | Function")]),e._v(" "),a("p",[e._v("（1）String，表示的是 HTML 标签名")]),e._v(" "),a("p",[e._v("（2）Object ，一个含有数据的组件选项对象")]),e._v(" "),a("p",[e._v("（3）Function ，返回了一个含有标签名或者组件选项对象的 async 函数")]),e._v(" "),a("p",[e._v("createElement 第二个参数是选填的，一个与模板中属性对应的数据对象 常用的有 class | style | attrs | domProps | on")]),e._v(" "),a("p",[e._v("（1）class：控制类名")]),e._v(" "),a("p",[e._v("（2）style ：样式")]),e._v(" "),a("p",[e._v("（3）attrs ：用来写正常的 html 属性 id src 等等")]),e._v(" "),a("p",[e._v("（4）domProps :用来写原生的 dom 属性")]),e._v(" "),a("p",[e._v("（5）on:：用来写原生方法")]),e._v(" "),a("p",[e._v("createElement 第三个参数是选填的，代表子级虚拟节点 (VNodes)，由 createElement() 构建而成，正常来讲接收的是一个字符串或者一个数组，一般数组用的是比较多的")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("如果组件是一个函数组件，渲染函数还会接收一个额外的 context 参数，为没有实例的函数组件提供上下文信息。")])]),e._v(" "),a("h3",{attrs:{id:"render-函数在什么时候触发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#render-函数在什么时候触发"}},[e._v("#")]),e._v(" render 函数在什么时候触发？")]),e._v(" "),a("p",[e._v("第一次挂载和每次数据更新都会触发 render 函数。")]),e._v(" "),a("h3",{attrs:{id:"template-与-render-函数对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#template-与-render-函数对比"}},[e._v("#")]),e._v(" template 与 render 函数对比")]),e._v(" "),a("p",[e._v("相同之处：")]),e._v(" "),a("p",[e._v("render 函数 跟 template 一样都是创建 html 模板")]),e._v(" "),a("p",[e._v("不同之处：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("Template 适合逻辑简单，render 适合复杂逻辑。")])]),e._v(" "),a("li",[a("p",[e._v("使用者 template 理解起来相对容易，但灵活性不足；自定义 render 函数灵活性高，但对使用者要求较高。")])]),e._v(" "),a("li",[a("p",[e._v("render 的性能较高，template 性能较低。使用 render 函数渲染没有编译过程，相当于使用者直接将代码给程序。所以，使用它对使用者要求高，且易出现错误")])]),e._v(" "),a("li",[a("p",[e._v("Render 函数的优先级要比 template 的级别要高，但是要注意的是 Mustache(双花括号)语法就不能再次使用")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);