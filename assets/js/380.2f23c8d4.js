(window.webpackJsonp=window.webpackJsonp||[]).push([[380],{851:function(v,_,t){"use strict";t.r(_);var l=t(13),p=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"数据结构和算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法"}},[v._v("#")]),v._v(" 数据结构和算法")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("数组和链表随机访问的时间复杂度，数组和链表的区别，数组和链表优点缺点，应用场景【描述】")])]),v._v(" "),t("li",[t("p",[v._v("数组有 10 万个数据，取第一个和取第 10 万个的耗时多久？")])]),v._v(" "),t("li",[t("p",[v._v("你觉得递归有什么缺点？怎么改进代码（爆栈和内存溢出）")])])]),v._v(" "),t("blockquote",[t("p",[v._v("爆栈属于什么类型的错误？系统错误还是什么？（没答上来...）")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("如何判断链表是否有环？不用快慢指针的话有什么方法？")])]),v._v(" "),t("li",[t("p",[v._v("简单说下栈和队列？如何用栈实现队列？")])]),v._v(" "),t("li",[t("p",[v._v("栈和队列特点?相互实现?")])]),v._v(" "),t("li",[t("p",[v._v("链表有环怎么判断?环的长度怎么计算？")])])]),v._v(" "),t("p",[v._v("尾递归、尾调用")]),v._v(" "),t("p",[v._v("最小生成树的定义和构建过程，知道的算法实现思路都说一下")]),v._v(" "),t("p",[v._v("B 树、B+树的区别")]),v._v(" "),t("p",[v._v("栈、队列、堆的分别使用场景，链表平时有用到吗")]),v._v(" "),t("p",[v._v("KMP 算法和 KMP 改进算法的具体思路和实现方法")]),v._v(" "),t("p",[v._v("哈希存储结构的构成方式 （哈希值，哈希表，哈希冲突）")]),v._v(" "),t("h3",{attrs:{id:"排序算法面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#排序算法面试题"}},[v._v("#")]),v._v(" 排序算法面试题")]),v._v(" "),t("p",[v._v("常用的排序算法，时间复杂度和空间复杂度分别是多少，说说快排的优化")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("二分查找的时间复杂度是多少，简要描述一下过程，O(logN)是怎么算出来的，TopK 的时间复杂度是多少，快排的时间复杂度是多少")])]),v._v(" "),t("li",[t("p",[v._v("归并排序的思路是什么，一个数组做归并排序的话，一共经历了多少次合并")])]),v._v(" "),t("li",[t("p",[v._v("希尔排序的时间复杂度和空间复杂度多少？")])])]),v._v(" "),t("p",[v._v("快排思路及时间复杂度，如果头尾指针每次相遇都在 1/3 处，其时间复杂度是多少（orz）")]),v._v(" "),t("h2",{attrs:{id:"算法题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#算法题"}},[v._v("#")]),v._v(" 算法题")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("实现 36 进制转换")])]),v._v(" "),t("li",[t("p",[v._v("算法：树的遍历有几种方式，实现下层次遍历")])]),v._v(" "),t("li",[t("p",[v._v("算法：判断对称二叉树")])]),v._v(" "),t("li",[t("p",[v._v("合并乱序区间")])]),v._v(" "),t("li",[t("p",[v._v("LRU 算法")])])]),v._v(" "),t("blockquote",[t("p",[v._v("这个题我最开始用 Map 做的，面试官跟我说如果不用 Map，如何实现每次查询和删除都能做到 O(1)，我没思路，面试官问我查询 O(1)用什么，我说用哈希，问我插入删除 O(1)用什么，我说用链表，可我不知道怎么结合到一起，面试官提示我可以用双向链表，然后我才做出来的")])]),v._v(" "),t("ul",[t("li",[v._v("有向图判断是否有环。")])]),v._v(" "),t("h3",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("给你一个已经升序排列的数组，给一个数字，找一下这个数字在这个数组里出现了几次")])]),v._v(" "),t("li",[t("p",[v._v("合并两个有序数组")])]),v._v(" "),t("li",[t("p",[v._v("合并多个有序数组")])])]),v._v(" "),t("blockquote",[t("p",[v._v("这题里我解答完之后自认为时间复杂度是 O(n2)，循环中用到了 shift 这个方法，面试官问我这个的时间复杂度是多少，我说是 O(n)，面试官说有什么办法可以解决这个么，我说可以基于原有的方式倒着循环，这样就可以用 pop 代替 shift 了，面试官问我为什么 pop 时间复杂度是 O(1)，我说不知道，面试官让我有时间可以去了解一下均摊算法")])]),v._v(" "),t("ul",[t("li",[v._v("输出数组中频率第二高的元素的下标")])]),v._v(" "),t("p",[v._v("在一个无序数组中找到第二大的数")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("对去重算法进行 O(n)的时间复杂度的优化 并且不能使用 Set,")])]),v._v(" "),t("li",[t("p",[v._v("去重算法再度升级 只能去重引用类型")])])]),v._v(" "),t("h3",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),t("p",[v._v("单向链表反转")])])}),[],!1,null,null,null);_.default=p.exports}}]);