(window.webpackJsonp=window.webpackJsonp||[]).push([[382],{932:function(t,e,a){"use strict";a.r(e);var r=a(14),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"_29-vue-为何采用异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-vue-为何采用异步渲染"}},[t._v("#")]),t._v(" 29.vue 为何采用异步渲染")]),t._v(" "),a("ul",[a("li",[t._v("为了提高性能\n"),a("blockquote",[a("p",[t._v("在 vue 中，响应式数据是组件级的，也就是说，每一次的更新都是渲染整个组件，如果是同步的话，根据我们前边理解的响应式数据原理，一旦修改了 data 属性，便会触发对应的 watcher，然后调用对应 watcher 下的 update 方法更新视图，那么结果显而易见，太频繁了")])])])]),t._v(" "),a("h3",{attrs:{id:"_29-1-vue-渲染机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-1-vue-渲染机制"}},[t._v("#")]),t._v(" 29.1. vue 渲染机制")]),t._v(" "),a("blockquote",[a("p",[t._v("使用 render 属性，配合单文件组件，createElement 函数渲染。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);