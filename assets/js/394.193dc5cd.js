(window.webpackJsonp=window.webpackJsonp||[]).push([[394],{867:function(e,t,v){"use strict";v.r(t);var a=v(24),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"vue-基础面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-基础面试题"}},[e._v("#")]),e._v(" vue 基础面试题")]),e._v(" "),v("h3",{attrs:{id:"mvvm、mvc、mvp-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mvvm、mvc、mvp-的区别"}},[e._v("#")]),e._v(" MVVM、MVC、MVP 的区别")]),e._v(" "),v("h3",{attrs:{id:"vue-和-react-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-区别"}},[e._v("#")]),e._v(" vue 和 react 区别")]),e._v(" "),v("p",[e._v("相同点：数据驱动视图、组件化、使用 Virtual DOM")]),e._v(" "),v("ol",[v("li",[e._v("数据流向的不同。")])]),e._v(" "),v("p",[e._v("react 从诞生开始就推崇单向数据流，而 Vue 是双向数据流")]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[e._v("数据变化的实现原理不同。")])]),e._v(" "),v("p",[e._v("react 使用的是不可变数据（手动 setState），而 Vue 使用的是可变的数据")]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[e._v("模板渲染方式的不同")])]),e._v(" "),v("p",[e._v("react 是通过 JSX 渲染模板，Vue 是通过一种拓展的 HTML 语法进行渲染")]),e._v(" "),v("h3",{attrs:{id:"vue-和-jquery-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-jquery-区别"}},[e._v("#")]),e._v(" vue 和 jquery 区别")]),e._v(" "),v("ol",[v("li",[e._v("vue 双向数据绑定")])]),e._v(" "),v("p",[e._v("在 Vue 中数据改变，视图无需刷新即可实时改变，而 jQuery 中数据改变，视图需要用户手动刷新才会改变。")]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[e._v("性能-减少 dom 的操作")])]),e._v(" "),v("p",[e._v("vue 使用了虚拟 dom 技术，能够减少 dom 操作")]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[e._v("组件化")])]),e._v(" "),v("p",[e._v("Vue 组件具有独立的逻辑和功能或界面，同时又能根据规定的接口规则进行相互融合，变成一个完整的应用")]),e._v(" "),v("p",[e._v("Vue 组件的优势就是组件进行重复使用，便于协同开发，提高开发效率。")]),e._v(" "),v("h3",{attrs:{id:"proxy-和-object-defineproperty-的对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#proxy-和-object-defineproperty-的对比"}},[e._v("#")]),e._v(" Proxy 和 Object.defineProperty 的对比")]),e._v(" "),v("p",[e._v("Proxy 的优势如下")]),e._v(" "),v("ol",[v("li",[e._v("Proxy 可以直接监听整个对象而非属性。")]),e._v(" "),v("li",[e._v("Proxy 可以直接监听数组的变化。")]),e._v(" "),v("li",[e._v("Proxy 有 13 中拦截方法，如 ownKeys、deleteProperty、has 等是 Object.defineProperty 不具备的。")]),e._v(" "),v("li",[e._v("Proxy 返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改;")]),e._v(" "),v("li",[e._v("Proxy 做为新标准将受到浏览器产商重点持续的性能优化,也就是传说中的新标准的性能红利。")])]),e._v(" "),v("p",[e._v("Object.defineProperty 的优势如下")]),e._v(" "),v("p",[e._v("兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平。")]),e._v(" "),v("p",[e._v("Object.defineProperty 不足在于：")]),e._v(" "),v("ol",[v("li",[e._v("Object.defineProperty 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。")]),e._v(" "),v("li",[e._v("Object.defineProperty 不能监听数组。是通过重写数据的那 7 个可以改变数据的方法来对数组进行监听的。")]),e._v(" "),v("li",[e._v("Object.defineProperty 也不能对 es6 新产生的 Map,Set 这些数据结构做出监听。")]),e._v(" "),v("li",[e._v("Object.defineProperty 也不能监听新增和删除操作，通过 Vue.set()和 Vue.delete 来实现响应式的。")])]),e._v(" "),v("h3",{attrs:{id:"computed-和-watch-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别"}},[e._v("#")]),e._v(" computed 和 watch 的区别")]),e._v(" "),v("ol",[v("li",[e._v("缓存支持")])]),e._v(" "),v("p",[e._v("watch 不支持缓存，数据变，直接会触发相应的操作；")]),e._v(" "),v("p",[e._v("computed 支持缓存，只有依赖数据发生改变，才会重新进行计算")]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[e._v("异步支持")])]),e._v(" "),v("p",[e._v("watch 支持异步；")]),e._v(" "),v("p",[e._v("computed 不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化")]),e._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[e._v("使用场景")])]),e._v(" "),v("p",[e._v("watch 当一个属性发生变化时，需要执行对应的操作；一对多或者一对一；")]),e._v(" "),v("p",[e._v("computed 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用 computed")]),e._v(" "),v("h3",{attrs:{id:"v-show-与-v-if-有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v-show-与-v-if-有什么区别"}},[e._v("#")]),e._v(" v-show 与 v-if 有什么区别？")]),e._v(" "),v("ul",[v("li",[v("ol",[v("li",[e._v("手段：")])]),e._v(" "),v("blockquote",[v("p",[e._v("v-if 是通过控制 dom 节点的存在与否来控制元素的显隐；\nv-show 是通过设置 DOM 元素的 display 样式，block 为显示，none 为隐藏；")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"2"}},[v("li",[e._v("编译过程：")])]),e._v(" "),v("blockquote",[v("p",[e._v("v-if 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；\nv-show 只是简单的基于 css 切换；")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"3"}},[v("li",[e._v("编译条件：")])]),e._v(" "),v("blockquote",[v("p",[e._v("v-if 是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载);\nv-show 是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且 DOM 元素保留；")])])]),e._v(" "),v("li",[v("ol",{attrs:{start:"4"}},[v("li",[e._v("性能消耗：")])]),e._v(" "),v("blockquote",[v("p",[e._v("v-if 有更高的切换消耗；\nv-show 有更高的初始渲染消耗；")])])]),e._v(" "),v("li",[v("p",[e._v("使用场景：")]),e._v(" "),v("blockquote",[v("p",[e._v("如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。v-if 判断是否加载，可以减轻服务器的压力，在需要时加载, 但有更高的切换开销")])])])]),e._v(" "),v("h3",{attrs:{id:"vue-组件通信方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件通信方式"}},[e._v("#")]),e._v(" vue 组件通信方式")]),e._v(" "),v("h3",{attrs:{id:"data-为什么要-return"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#data-为什么要-return"}},[e._v("#")]),e._v(" data 为什么要 return")]),e._v(" "),v("p",[e._v("避免 data 都将指向同一个地址,造成数据污染")]),e._v(" "),v("h3",{attrs:{id:"父子组件生命周期钩子函数执行顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父子组件生命周期钩子函数执行顺序"}},[e._v("#")]),e._v(" 父子组件生命周期钩子函数执行顺序？")]),e._v(" "),v("blockquote",[v("p",[e._v("Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：")])]),e._v(" "),v("ul",[v("li",[v("p",[e._v("加载渲染过程")]),e._v(" "),v("blockquote",[v("p",[e._v("父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted")])])]),e._v(" "),v("li",[v("p",[e._v("子组件更新过程")]),e._v(" "),v("blockquote",[v("p",[e._v("父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated")])])]),e._v(" "),v("li",[v("p",[e._v("父组件更新过程")]),e._v(" "),v("blockquote",[v("p",[e._v("父 beforeUpdate -> 父 updated")])])]),e._v(" "),v("li",[v("p",[e._v("销毁过程")]),e._v(" "),v("blockquote",[v("p",[e._v("父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed")])])])]),e._v(" "),v("h3",{attrs:{id:"vue2-的生命周期钩子"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue2-的生命周期钩子"}},[e._v("#")]),e._v(" vue2 的生命周期钩子")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("beforeCreate：组件刚被创建，组件属性计算之前")])]),e._v(" "),v("li",[v("p",[e._v("created：组件实例创建完成，属性已绑定， 但真实 dom 还没有生成，$el 还不可用,但是 data 和 method 可用")])]),e._v(" "),v("li",[v("p",[e._v("beforeMount：此时已经完成了模板的编译，在页面挂载开始之前被调用, 相关的 render 函数首次被调用")])]),e._v(" "),v("li",[v("p",[e._v("mounted：已经将编译好的模板，挂载到了页面指定的容器中显示,可操作 DOM（最早）")])]),e._v(" "),v("li",[v("p",[e._v("beforeUpdate：状态更新之前执行此函数，此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，此时还没有开始重新渲染 DOM 节点")])]),e._v(" "),v("li",[v("p",[e._v("updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！")])]),e._v(" "),v("li",[v("p",[e._v("beforeDestroy：实例销毁之前调用。在这一步，实例（data,methods,过滤器，指令）仍然完全可用。")]),e._v(" "),v("blockquote",[v("p",[e._v("使用场景：(日期在我点击查询的时候要存储,刷新就读内存,但是我点击其他页面再进来的时候,这个内存要清空)")])])]),e._v(" "),v("li",[v("p",[e._v("destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。")])]),e._v(" "),v("li",[v("p",[e._v("activited keep-alive 专属，组件被激活时调用")])]),e._v(" "),v("li",[v("p",[e._v("deactivated keep-alive 专属，组件被销毁时调用")])])]),e._v(" "),v("h3",{attrs:{id:"vue-组件的异步加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件的异步加载"}},[e._v("#")]),e._v(" vue 组件的异步加载")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("vue 提供的工厂函数")])]),e._v(" "),v("li",[v("p",[e._v("webpack 和 ES6 的"),v("code",[e._v("import")]),e._v("返回一个 Promise")])]),e._v(" "),v("li",[v("p",[e._v("webpack 提供的 require.ensure")])])]),e._v(" "),v("h3",{attrs:{id:"vue-常见修饰符及作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见修饰符及作用"}},[e._v("#")]),e._v(" vue 常见修饰符及作用")]),e._v(" "),v("h2",{attrs:{id:"vue-高级面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-高级面试题"}},[e._v("#")]),e._v(" vue 高级面试题")]),e._v(" "),v("h2",{attrs:{id:"vue-router-面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-面试题"}},[e._v("#")]),e._v(" vue-router 面试题")]),e._v(" "),v("h3",{attrs:{id:"路由模式-hash-与-histary-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路由模式-hash-与-histary-的区别"}},[e._v("#")]),e._v(" 路由模式 hash 与 histary 的区别")]),e._v(" "),v("h2",{attrs:{id:"vuex-面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuex-面试题"}},[e._v("#")]),e._v(" vuex 面试题")]),e._v(" "),v("h2",{attrs:{id:"vue3-面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue3-面试题"}},[e._v("#")]),e._v(" vue3 面试题")])])}),[],!1,null,null,null);t.default=r.exports}}]);