(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{532:function(t,a,v){t.exports=v.p+"assets/img/front-cache.85a710c9.png"},533:function(t,a,v){t.exports=v.p+"assets/img/cache.19a12114.png"},534:function(t,a,v){t.exports=v.p+"assets/img/http-cache.7f549210.png"},535:function(t,a,v){t.exports=v.p+"assets/img/cache-request1.5f6dc071.png"},536:function(t,a,v){t.exports=v.p+"assets/img/cache-request2.dac0900d.png"},537:function(t,a){t.exports="data:image/png;base64,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"},979:function(t,a,v){"use strict";v.r(a);var e=v(14),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"缓存简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存简介"}},[t._v("#")]),t._v(" 缓存简介")]),t._v(" "),e("blockquote",[e("p",[t._v("缓存控制：控制缓存的开关，用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式。")])]),t._v(" "),e("blockquote",[e("p",[t._v("缓存校验：如何校验缓存，比如怎么定义缓存的有效期，怎么确保缓存是最新的。")])]),t._v(" "),e("blockquote",[e("p",[t._v("缓存命中率：从缓存中得到数据的请求数与所有请求数的比率。理想状态是越高越好。")])]),t._v(" "),e("blockquote",[e("p",[t._v("控制缓存开关的字段有两个：Pragma 和 Cache-Control。")])]),t._v(" "),e("ul",[e("li",[t._v("禁止浏览器从本地计算机的缓存中访问页面内容 "),e("code",[t._v('＜meta http-equiv="Pragma" content="no-cache"＞')])])]),t._v(" "),e("h3",{attrs:{id:"缓存作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存作用"}},[t._v("#")]),t._v(" 缓存作用")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("减少网络带宽消耗")]),t._v("：无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当 Web 缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("降低服务器压力")]),t._v("：给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("减少网络延迟")]),t._v("，加快页面打开速度：带宽对于个人网站运营者来说是十分重要，而对于大型的互联网公司来说，可能有时因为钱多而真的不在乎。那 Web 缓存还有作用吗？答案是肯定的，对于最终用户，缓存的使用能够明显加快页面打开速度，达到更好的体验。")])])]),t._v(" "),e("h3",{attrs:{id:"缓存介质"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存介质"}},[t._v("#")]),t._v(" 缓存介质")]),t._v(" "),e("p",[t._v("虽然从硬件介质上来看，无非就是内存和硬盘两种，但从技术上，可以分成内存、硬盘文件、数据库。")]),t._v(" "),e("ol",[e("li",[e("p",[e("strong",[t._v("内存")]),t._v("：将缓存存储于内存中是最快的选择，无需额外的 I/O 开销，但是内存的缺点是没有持久化落地物理磁盘，一旦应用异常 break down 而重新启动，数据很难或者无法复原。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("硬盘")]),t._v("：一般来说，很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("数据库")]),t._v("：前面有提到，增加缓存的策略的目的之一就是为了减少数据库的 I/O 压力。现在使用数据库做缓存介质是不是又回到了老问题上了？其实，数据库也有很多种类型，像那些不支持 SQL，只是简单的 key-value 存储结构的特殊数据库（如 BerkeleyDB 和 Redis），响应速度和吞吐量都远远高于我们常用的关系型数据库等。")])])]),t._v(" "),e("h2",{attrs:{id:"前端缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端缓存"}},[t._v("#")]),t._v(" 前端缓存")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("前端缓存主要可以分为 HTTP 缓存和浏览器缓存。")])])]),t._v(" "),e("p",[e("img",{attrs:{src:v(532),alt:"image"}})]),t._v(" "),e("h3",{attrs:{id:"缓存流程图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存流程图"}},[t._v("#")]),t._v(" 缓存流程图")]),t._v(" "),e("p",[e("img",{attrs:{src:v(533),alt:"image"}})]),t._v(" "),e("h2",{attrs:{id:"http-缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" HTTP 缓存")]),t._v(" "),e("h3",{attrs:{id:"http-缓存分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存分类"}},[t._v("#")]),t._v(" http 缓存分类")]),t._v(" "),e("p",[e("img",{attrs:{src:v(534),alt:"image"}})]),t._v(" "),e("h3",{attrs:{id:"http-缓存过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存过程"}},[t._v("#")]),t._v(" http 缓存过程")]),t._v(" "),e("p",[t._v("浏览器第一次发起请求步骤：")]),t._v(" "),e("blockquote",[e("p",[t._v("在第一次请求时，服务器会将页面最后修改时间通过 Last-Modified 标识由服务器发送给客户端，客户端记录修改时间；服务器还会生成一个 Etag，并发送给客户端。")])]),t._v(" "),e("p",[e("img",{attrs:{src:v(535),alt:"image"}})]),t._v(" "),e("p",[t._v("浏览器后续再次进行请求时：")]),t._v(" "),e("p",[e("img",{attrs:{src:v(536),alt:"image"}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("(1) 判断是否是强缓存：浏览器在请求某一资源时，会先获取该资源缓存的 header 信息，判断是否命中强缓存（cache-control 和 expires 信息），若命中直接从缓存中获取资源信息，包括缓存 header 信息；本次请求根本就不会与服务器进行通信；")])]),t._v(" "),e("li",[e("p",[t._v("(2) 判断是否是协商缓存：如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的 header 字段信息（Last-Modified/If-Modified-Since 和 Etag/If-None-Match），由服务器根据请求中的相关 header 信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应 header 信息更新缓存中的对应 header 信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容")])])]),t._v(" "),e("h3",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),e("blockquote",[e("p",[t._v("强缓存：强制从浏览器缓存中查找该次请求的标识和内容，然后根据该结果的缓存规则，来决定是否使用浏览器缓存。")])]),t._v(" "),e("blockquote",[e("p",[t._v("控制强制缓存的字段是"),e("code",[t._v("Expires")]),t._v("和"),e("code",[t._v("Cache-Control")]),t._v(" Cache-Control 优先级比 Expires 高。")])]),t._v(" "),e("ul",[e("li",[t._v("Cache-Control")])]),t._v(" "),e("blockquote",[e("p",[t._v("Cache-Control：请求/响应头，缓存控制字段，精确控制缓存策略。")])]),t._v(" "),e("blockquote",[e("p",[t._v("在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：")])]),t._v(" "),e("ol",[e("li",[e("p",[t._v("public：所有内容都将被缓存（客户端和代理服务器（如 CDN）都可缓存）")])]),t._v(" "),e("li",[e("p",[t._v("private：所有内容只有客户端可以缓存，Cache-Control 的默认取值")])]),t._v(" "),e("li",[e("p",[t._v("no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定")])]),t._v(" "),e("li",[e("p",[t._v("no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存")])]),t._v(" "),e("li",[e("p",[t._v("max-age=xxx (xxx is numeric)：缓存内容将在 xxx 秒后失效")])])]),t._v(" "),e("ul",[e("li",[t._v("Expires")])]),t._v(" "),e("blockquote",[e("p",[t._v("简介：响应头，代表该资源的过期时间。")])]),t._v(" "),e("blockquote",[e("p",[t._v("是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串")])]),t._v(" "),e("blockquote",[e("p",[t._v("这个时间代表这这个资源的失效时间，只要发送请求时间是在 Expires 之前，那么本地缓存始终有效，则在缓存中读取数据。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱")])]),t._v(" "),e("h3",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),e("blockquote",[e("p",[t._v("协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程：")])]),t._v(" "),e("blockquote",[e("p",[t._v("主要涉及到两组 header 字段：")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Etag 和 If-None-Match")])]),t._v(" "),e("li",[e("p",[t._v("Last-Modified 和 If-Modified-Since")])])]),t._v(" "),e("h4",{attrs:{id:"last-modified-if-modified-since"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[t._v("#")]),t._v(" Last-Modified/If-Modified-Since：")]),t._v(" "),e("ul",[e("li",[t._v("Last-Modified")])]),t._v(" "),e("blockquote",[e("p",[t._v("简介：响应头，资源最近修改时间，由服务器告诉浏览器。")])]),t._v(" "),e("ul",[e("li",[t._v("If-Modified-Since")])]),t._v(" "),e("blockquote",[e("p",[t._v("简介：请求头，资源最近修改时间，由浏览器告诉服务器。")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("(1) 浏览器第一次发送请求，让服务端在 response header 中返回请求的资源上次更新时间（Last-Modified 的值），浏览器会存下这个时间；")])]),t._v(" "),e("li",[e("p",[t._v("(2) 当浏览器下次请求时，request header 中带上 If-Modified-Since(即保存的 Last-Modified 的值)。根据浏览器发送的修改时间和服务端的 wh 修改时间进行比对，一致的话代码资源没有改变，服务端返回正文为空的响应，让浏览器在缓存中读取资源，从而减少请求消耗。")])])]),t._v(" "),e("blockquote",[e("p",[t._v("缺点：")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1、 Last-Modified 保存的是绝对时间，并且是精确到秒，所以如果资源在 1 秒内修改了多次的话，那就无法识别；")])]),t._v(" "),e("li",[e("p",[t._v("2、对于文件只改变了修改时间，内容不变，这时候也会使缓存失效，其实这个时候我们是不希望客户端重新请求的；")])]),t._v(" "),e("li",[e("p",[t._v("3、某些服务器不能精确的得到文件的最后修改时间；")])])]),t._v(" "),e("h4",{attrs:{id:"etag-if-none-match"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" ETag/If-None-Match:")]),t._v(" "),e("ul",[e("li",[t._v("ETag")])]),t._v(" "),e("blockquote",[e("p",[t._v("简介：响应头，资源标识，由服务器告诉浏览器。")])]),t._v(" "),e("ul",[e("li",[t._v("If-None-Match")])]),t._v(" "),e("blockquote",[e("p",[t._v("简介：请求头，缓存资源标识，由浏览器告诉服务器。")])]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("浏览器第一次发送一个请求得到 ETag 的值，然后在下一次请求 request header 中带上 If-none-match（即保存的 ETag 的值）；")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("通过发送的 ETag 的值和服务器重新生成的 ETag 的值进行比对，如果一致代表资源没有改变，服务器返回的正文为空的响应，让浏览器从缓存中读取资源，从而减少请求消耗。")])])])]),t._v(" "),e("p",[t._v("ETag 的工作机制跟 Last-Modified 基本一样。但是，ETag 是对资源内容使用抗碰撞散列函数（我也不知道是啥），使用最近修改的时间戳的哈希值。ETag 解决了 Last-Modified 上述问题。")]),t._v(" "),e("blockquote",[e("p",[t._v("缺点：")])]),t._v(" "),e("ul",[e("li",[t._v("ETag 虽然能解决问题，但也并非完美，ETag 每次服务端生成都需要进行读写操作（因为要生成 hash），而 Last-Modified 只需要读取操作，ETag 消耗更大一些。")])]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("Last-Modified 和 ETag 同样可以同时配置，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。")]),t._v(" "),e("p",[t._v("精确度上，ETag 更高，性能上 Etag 稍微低一点（因为要生成 hash）")]),t._v(" "),e("p",[t._v("由此可见，协商缓存其实受强缓存的影响，强缓存过期了且 Cache-Control 不为 no-store 时是否缓存才由协商缓存决定。")]),t._v(" "),e("h3",{attrs:{id:"为什么要有-etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有-etag"}},[t._v("#")]),t._v(" 为什么要有 etag")]),t._v(" "),e("p",[t._v("你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？HTTP1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；")])]),t._v(" "),e("li",[e("p",[t._v("某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说 1s 内修改了 N 次)，If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断(或者说 UNIX 记录 MTIME 只能精确到秒)；")])]),t._v(" "),e("li",[e("p",[t._v("某些服务器不能精确的得到文件的最后修改时间。")])])]),t._v(" "),e("p",[t._v("这时，利用 Etag 能够更加准确的控制缓存，因为 Etag 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。")]),t._v(" "),e("p",[t._v("Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag，一致的情况下，才会继续比对 Last-Modified，最后才决定是否返回 304。")]),t._v(" "),e("h3",{attrs:{id:"强缓存和协商缓存的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存和协商缓存的区别"}},[t._v("#")]),t._v(" 强缓存和协商缓存的区别")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("是否请求服务器：强缓存不发请求到服务器，协商缓存会发请求到服务器。")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("状态码不一致：强缓存 200，协商缓存为 304")])])])]),t._v(" "),e("h3",{attrs:{id:"三种方式设置浏览器过期时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三种方式设置浏览器过期时间"}},[t._v("#")]),t._v(" 三种方式设置浏览器过期时间")]),t._v(" "),e("blockquote",[e("p",[t._v("设置响应头（注意浏览器有自己的缓存替换策略，即便资源过期，不一定被浏览器删除。同样资源未过期，可能由于缓存空间不足而被其他网页新的缓存资源所替换而被删除。）：")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1、设置 Cache-Control: max-age=1000 //响应头中的 Date 经过 1000s 过期")])]),t._v(" "),e("li",[e("p",[t._v("2、设置 Expires //此时间与本地时间(响应头中的 Date )对比，小于本地时间表示过期，由于本地时钟与服务器时钟无法保持一致，导致比较不精确")])]),t._v(" "),e("li",[e("p",[t._v("3、如果以上均未设置，却设置了 Last-Modified ，浏览器隐式的设置资源过期时间为 (Date - Last-Modified) * 10% 缓存过期时间。")])])]),t._v(" "),e("h3",{attrs:{id:"用户的行为对缓存的影响"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用户的行为对缓存的影响"}},[t._v("#")]),t._v(" 用户的行为对缓存的影响")]),t._v(" "),e("p",[e("img",{attrs:{src:v(537),alt:"image"}})]),t._v(" "),e("ul",[e("li",[t._v("如何重新加载强缓存缓存过的资源")])]),t._v(" "),e("p",[t._v("通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。加 query 值")]),t._v(" "),e("p",[t._v("例如："),e("code",[t._v('<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js?v=1.0.0"><\/script>')])]),t._v(" "),e("h2",{attrs:{id:"浏览器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存"}},[t._v("#")]),t._v(" 浏览器缓存")]),t._v(" "),e("h3",{attrs:{id:"cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[t._v("#")]),t._v(" cookie")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"cdn-缓存-服务端缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn-缓存-服务端缓存"}},[t._v("#")]),t._v(" CDN 缓存(服务端缓存)")]),t._v(" "),e("blockquote",[e("p",[t._v("CDN 缓存是一种服务端缓存"),e("br"),t._v("\nCDN 服务商将源站的资源缓存到遍布全国的高性能加速节点上，"),e("br"),t._v("\n当用户访问相应的业务资源时，用户会被调度至最接近的节点最近的节点 ip 返回给用户，"),e("br"),t._v("\n在 web 性能优化中，它主要起到了，缓解源站压力，优化不同用户的访问速度与体验的作用。")])]),t._v(" "),e("p",[t._v("CDN 的优势：")]),t._v(" "),e("ul",[e("li",[t._v("（1）CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；")]),t._v(" "),e("li",[t._v("（2）大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载。")])]),t._v(" "),e("p",[t._v("CDN 缺点：")]),t._v(" "),e("ul",[e("li",[t._v("当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户再浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常。")])]),t._v(" "),e("h3",{attrs:{id:"cdn-缓存策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn-缓存策略"}},[t._v("#")]),t._v(" CDN 缓存策略")]),t._v(" "),e("p",[t._v("CDN 边缘节点缓存策略因服务商不同而不同，但一般都会遵循 http 标准协议，通过 http 响应头中的 Cache-control: max-age 的字段来设置 CDN 边缘节点数据缓存时间。")]),t._v(" "),e("p",[t._v("当客户端向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN 节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。")]),t._v(" "),e("p",[t._v("CDN 服务商一般会提供基于文件后缀、目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。")]),t._v(" "),e("p",[t._v("CDN 缓存时间会对“回源率”产生直接的影响。若 CDN 缓存时间较短，CDN 边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若 CDN 缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。")]),t._v(" "),e("h3",{attrs:{id:"cdn-缓存刷新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn-缓存刷新"}},[t._v("#")]),t._v(" CDN 缓存刷新")]),t._v(" "),e("p",[t._v("CDN 边缘节点对开发者是透明的，相比于浏览器 Ctrl+F5 的强制刷新来使浏览器本地缓存失效，开发者可以通过 CDN 服务商提供的“刷新缓存”接口来达到清理 CDN 边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制 CDN 节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。")]),t._v(" "),e("h2",{attrs:{id:"dns-缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns-缓存"}},[t._v("#")]),t._v(" DNS 缓存")]),t._v(" "),e("p",[t._v("我们知道 url 其实只是一个别名，真实的服务器请求地址，实际上是一个 IP 地址。获得 IP 地址的方式，就是查询 DNS 映射表。虽然这是一个非常简单的查询，但如果每次用户访问一个 url 都去查询 DNS 一次，未免显得太频繁。DNS 会告诉你，你别老是经常过来，万一我挂了，我们就无法愉快地玩耍了。")]),t._v(" "),e("p",[t._v("DNS 查询过程大约消耗 20 毫秒，在 DNS 查询过程中，浏览器什么都不会做，保持空白。如果 DNS 查询很多，网页性能会受到很大影响，因此需要用到 DNS 缓存。\n不同浏览器的缓存机制不同： IE 对 DNS 记录默认的缓存时间为 30 分钟，Firefox 对 DNS 记录默认的缓存时间为 1 分钟，Chrome 对 DNS 记录默认的缓存时间为 1 分钟。")]),t._v(" "),e("p",[t._v("缓存时间长：减少 DNS 的重复查找，节省时间。\n缓存时间短：及时检测服务器的 IP 变化，保证访问的正确性。")]),t._v(" "),e("h2",{attrs:{id:"缓存相关文章"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存相关文章"}},[t._v("#")]),t._v(" 缓存相关文章")]),t._v(" "),e("ul",[e("li",[t._v("缓存前端控制还是后端控制："),e("a",{attrs:{href:"https://www.jianshu.com/p/f7ccad796058",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.jianshu.com/p/f7ccad796058"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=s.exports}}]);