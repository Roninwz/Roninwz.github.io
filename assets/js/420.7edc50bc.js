(window.webpackJsonp=window.webpackJsonp||[]).push([[420],{968:function(t,r,v){"use strict";v.r(r);var _=v(14),a=Object(_.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"html-面试题及答案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html-面试题及答案"}},[t._v("#")]),t._v(" html 面试题及答案")]),t._v(" "),v("h3",{attrs:{id:"html5-新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#html5-新特性"}},[t._v("#")]),t._v(" html5 新特性")]),t._v(" "),v("ol",[v("li",[t._v("文档类型声明")])]),t._v(" "),v("p",[t._v("HTML5 的文档声明相对来说更为简便 "),v("code",[t._v("<!DOCTYPE html>")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("音视频的支持")])]),t._v(" "),v("p",[t._v("audio 和 video 标签")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("图形的支持")])]),t._v(" "),v("p",[t._v("svg 和 canvas")]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("新增了一些语义化元素和移除元素")])]),t._v(" "),v("p",[t._v("新增：article、nav、details、footer、header、main、time、canvas、svg、audio、video 等标签")]),t._v(" "),v("p",[t._v("移除：font、center、u、big、strike、tt 等标签")]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("会话存储和本地存储")])]),t._v(" "),v("p",[t._v("localStorage、sessionStorage")]),t._v(" "),v("h3",{attrs:{id:"严格模式和混杂模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#严格模式和混杂模式"}},[t._v("#")]),t._v(" 严格模式和混杂模式")]),t._v(" "),v("p",[t._v("严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。")]),t._v(" "),v("p",[t._v("混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。")]),t._v(" "),v("p",[t._v("区分：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）")])]),t._v(" "),v("li",[v("p",[t._v("有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式")])]),t._v(" "),v("li",[v("p",[t._v("DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD 不存在或者格式不正确——混杂模式）")])]),t._v(" "),v("li",[v("p",[t._v("HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）")])])]),t._v(" "),v("h3",{attrs:{id:"attribute-和-property-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#attribute-和-property-的区别"}},[t._v("#")]),t._v(" attribute 和 property 的区别")]),t._v(" "),v("p",[t._v("详解：")]),t._v(" "),v("p",[t._v("attribute： 是 dom 元素在文档中作为 html 标签拥有的属性，如 id,class,src,title,alt 等标签属性，")]),t._v(" "),v("p",[t._v("也可以自定义属性，通过 "),v("code",[t._v("dom.setAttribute('class', 'a')")]),t._v(" 来设置属性，通过 "),v("code",[t._v("dom.getAttribute('class', 'a')")]),t._v("来获取属性；")]),t._v(" "),v("p",[t._v("property: 就是 dom 元素在 js 中作为对象拥有的属性。 赋值 dom.className = 'a' ;取值 dom.className;")]),t._v(" "),v("p",[t._v("相同点：对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的。")]),t._v(" "),v("p",[t._v("区别：但是对于自定义的属性来说， "),v("code",[t._v('dom.test="";')]),t._v("没修改成功 。 test 自定义属性还存在。")]),t._v(" "),v("h3",{attrs:{id:"src-和-href-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#src-和-href-的区别"}},[t._v("#")]),t._v(" src 和 href 的区别")]),t._v(" "),v("ol",[v("li",[t._v("请求资源类型不同")])]),t._v(" "),v("p",[t._v("（1） href 是 Hypertext Reference 的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。")]),t._v(" "),v("p",[t._v("（2）在请求 src 资源时会将其指向的资源下载并应用到文档中，常用的有 script，img 、iframe；")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("作用结果不同")])]),t._v(" "),v("p",[t._v("（1）href 用于在当前文档和引用资源之间确立联系；")]),t._v(" "),v("p",[t._v("（2）src 用于替换当前内容；")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("浏览器解析方式不同")])]),t._v(" "),v("p",[t._v("（1）若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。")]),t._v(" "),v("p",[t._v("（2）当浏览器解析到 src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。")]),t._v(" "),v("h3",{attrs:{id:"link-和-import-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#link-和-import-的区别"}},[t._v("#")]),t._v(" link 和@import 的区别")]),t._v(" "),v("p",[t._v("两者都是外部引用 CSS 的方式，但是存在一定的区别：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("（1）link 是 XHTML 标签，除了能够加载 CSS，还可以定义 RSS 等其他事务；而@import 属于 CSS 范畴，只可以加载 CSS。")])]),t._v(" "),v("li",[v("p",[t._v("（2）link 引用 CSS 时，在页面载入时同时加载；@import 需要页面完全载入以后再加载。")])]),t._v(" "),v("li",[v("p",[t._v("（3）link 是 XHTML 标签，无兼容问题；@import 则是在 CSS2.1 提出的，低版本的浏览器不支持。")])]),t._v(" "),v("li",[v("p",[t._v("（4）link 支持使用 Javascript 控制 DOM 改变样式；而@import 不支持。")])])]),t._v(" "),v("h3",{attrs:{id:"image-标签中-alt-和-title-有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#image-标签中-alt-和-title-有什么区别"}},[t._v("#")]),t._v(" Image 标签中 alt 和 title 有什么区别")]),t._v(" "),v("p",[t._v("图片中的 alt 属性是在图片不能正常显示时出现的文本提示。")]),t._v(" "),v("p",[t._v("图片中的 title 属性是在鼠标在移动到元素上的文本提示。")]),t._v(" "),v("blockquote",[v("p",[t._v("参考："),v("a",{attrs:{href:"https://www.runoob.com/note/28846",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.runoob.com/note/28846"),v("OutboundLink")],1)])]),t._v(" "),v("h3",{attrs:{id:"link-标签-prefetch、preload-作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#link-标签-prefetch、preload-作用"}},[t._v("#")]),t._v(" link 标签 prefetch、preload 作用")]),t._v(" "),v("p",[t._v("preload 和 prefetch 的出现为我们提供了可以更加细粒度地控制浏览器加载资源的方法。")]),t._v(" "),v("p",[t._v("相同点： preload 和 prefetch 都没有同域名的限制；")]),t._v(" "),v("ol",[v("li",[t._v("preload")])]),t._v(" "),v("p",[t._v("link 标签的 preload 是一种声明式的资源获取请求方式，用于提前加载一些需要的依赖，并且不会影响页面的 onload 事件，")]),t._v(" "),v("p",[t._v("适用场景：本页面接下来大概率要使用的资源")]),t._v(" "),v("p",[t._v("加载时间：立即加载（一般而言，跟 as 有关）")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("prefetch")])]),t._v(" "),v("p",[t._v("pretch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟（无论资源是否可以缓存）；并且，当页面跳转时，未完成的 prefetch 请求不会被中断；")]),t._v(" "),v("p",[t._v("适用场景：下个页面的资源。下个页面很可能会去访问")]),t._v(" "),v("p",[t._v("加载时间：浏览器闲置的时候才会加载（一般而言）")]),t._v(" "),v("blockquote",[v("p",[t._v("参考："),v("a",{attrs:{href:"https://www.jianshu.com/p/16bffc804868",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.jianshu.com/p/16bffc804868"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=a.exports}}]);