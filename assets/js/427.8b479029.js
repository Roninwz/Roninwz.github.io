(window.webpackJsonp=window.webpackJsonp||[]).push([[427],{974:function(t,p,v){"use strict";v.r(p);var e=v(14),_=Object(e.a)({},(function(){var t=this,p=t.$createElement,v=t._self._c||p;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"typescript"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" typescript")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("typescript 和 javascript 区别")])]),t._v(" "),v("li",[v("p",[t._v("typescript 你都用过哪些类型")])]),t._v(" "),v("li",[v("p",[t._v("typescript 中 type 和 interface 的区别")])]),t._v(" "),v("li",[v("p",[t._v("TypeScript 中 any、never、unknown 和 void 有什么区别？")])]),t._v(" "),v("li",[v("p",[t._v("Never 和 void 的区别")])]),t._v(" "),v("li",[v("p",[t._v("讲讲函数重载？")])]),t._v(" "),v("li",[v("p",[t._v("Ts 有什么优势")])]),t._v(" "),v("li",[v("p",[t._v("typescript 定义一个对象应该如何定义，如果定义对象的 key 必须是字符串，应该如何定义")])]),t._v(" "),v("li",[v("p",[t._v("typescript 装饰器有了解么，类装饰器的 this 是如何处理的")])]),t._v(" "),v("li",[v("p",[t._v("js 和 ts 混合开发有没有最佳实践")])])]),t._v(" "),v("p",[t._v("TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？")]),t._v(" "),v("p",[t._v("TypeScript 中 any 类型的作用是什么？")]),t._v(" "),v("p",[t._v("TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？")]),t._v(" "),v("p",[t._v("TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？")]),t._v(" "),v("p",[t._v("TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？")]),t._v(" "),v("p",[t._v("TypeScript 中使用 Unions 时有哪些注意事项？")]),t._v(" "),v("p",[t._v("TypeScript 如何设计 Class 的声明？")]),t._v(" "),v("p",[t._v("TypeScript 中如何联合枚举类型的 Key?")]),t._v(" "),v("p",[t._v("TypeScript 中"),v("code",[t._v("?.、??、!.、_、**")]),t._v("等符号的含义？")]),t._v(" "),v("p",[t._v("TypeScript 中预定义的有条件类型有哪些？")]),t._v(" "),v("p",[t._v("简单介绍一下 TypeScript 模块的加载机制？")]),t._v(" "),v("p",[t._v("简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？")]),t._v(" "),v("p",[t._v("TypeScript 中对象展开会有什么副作用吗？")]),t._v(" "),v("p",[t._v("TypeScript 中 interface、type、enum 声明有作用域的功能吗？")]),t._v(" "),v("p",[t._v("TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？")]),t._v(" "),v("p",[t._v("如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？")]),t._v(" "),v("p",[t._v("TypeScript 的 tsconfig.json 中有哪些配置项信息？")]),t._v(" "),v("p",[t._v("TypeScript 中如何设置模块导入的路径别名？")]),t._v(" "),v("p",[t._v("有用过 ts 中的 keyof 吗？")]),t._v(" "),v("h2",{attrs:{id:"typescript-面试题及答案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript-面试题及答案"}},[t._v("#")]),t._v(" typescript 面试题及答案")]),t._v(" "),v("h3",{attrs:{id:"typescript-优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#typescript-优缺点"}},[t._v("#")]),t._v(" typescript 优缺点")]),t._v(" "),v("p",[t._v("优点：")]),t._v(" "),v("ol",[v("li",[t._v("TypeScript 增加了代码的可读性和可维护性")])]),t._v(" "),v("p",[t._v("（1）类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了")]),t._v(" "),v("p",[t._v("（2）可以在编译阶段就发现大部分错误，这总比在运行时候出错好")]),t._v(" "),v("p",[t._v("（3）增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("TypeScript 非常包容")])]),t._v(" "),v("p",[t._v("（1）TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可")]),t._v(" "),v("p",[t._v("（2）即使不显式的定义类型，也能够自动做出类型推论")]),t._v(" "),v("p",[t._v("（3）可以定义从简单到复杂的几乎一切类型")]),t._v(" "),v("p",[t._v("（4）即使 TypeScript 编译报错，也可以生成 JavaScript 文件")]),t._v(" "),v("p",[t._v("（5）兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取")]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("TypeScript 拥有活跃的社区")])]),t._v(" "),v("p",[t._v("缺点：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念")])]),t._v(" "),v("li",[v("p",[t._v("短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本")])])]),t._v(" "),v("h3",{attrs:{id:"_1-typescript-和-javascript-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-typescript-和-javascript-区别"}},[t._v("#")]),t._v(" 1.typescript 和 javascript 区别")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，")])]),t._v(" "),v("li",[v("p",[t._v("TypeScript 通过类型注解提供编译时的静态类型检查。")])]),t._v(" "),v("li",[v("p",[t._v("后缀不同：TypeScript 文件的后缀名 .ts （.ts，.tsx），JavaScript 文件是 .js")])]),t._v(" "),v("li",[v("p",[t._v("语言类型不同：TypeScript 是面向对象编程语言，JavaScript 是脚本语言")])])]),t._v(" "),v("h3",{attrs:{id:"any、never、unknown-和-void-区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#any、never、unknown-和-void-区别"}},[t._v("#")]),t._v(" any、never、unknown 和 void 区别")]),t._v(" "),v("ol",[v("li",[t._v("定义")])]),t._v(" "),v("p",[t._v("any ：用于描述任意类型的变量，不作任何约束，编译时会跳过对其的类型检查")]),t._v(" "),v("p",[t._v("unknown ：表示未知类型，即写代码的时候还不知道具体会是怎样的数据类型")]),t._v(" "),v("p",[t._v("never ：永不存在的值的类型，常用于表示永不能执行到终点的函数返回值，例如抛出异常或函数中执行无限循环的代码（死循环）的函数返回值类型")]),t._v(" "),v("p",[t._v("void ：表示无任何类型，没有类型，例如没有返回值的函数的返回值类型")]),t._v(" "),v("p",[t._v("any 与 unknown 的区别：")]),t._v(" "),v("p",[t._v("(1) unknown 类型会更加严格：在对 unknown 类型的值执行大多数操作之前，我们必须进行断言或守卫")]),t._v(" "),v("p",[t._v("(2) any 类型导致问题太多了，如类型污染，使用不存在的属性或方法而不报错等，而且不不方便后期维护，所以，建议能不用 any 就不用 any，但是如果声明时并不确定具体的类型，则可以使用 unknown 代替，在使用时用类型断言或类型守卫进行类型收缩")]),t._v(" "),v("p",[t._v("never 与 void 的区别：")]),t._v(" "),v("p",[t._v("(1) 用于函数时， never 表示函数用于执行不到返回值那一步（抛出异常或死循环）的返回值类型，即永不存在的值的类型，而 void 则表示没有返回值，不返回或返回 undefined")]),t._v(" "),v("p",[t._v("参考："),v("a",{attrs:{href:"https://jishuin.proginn.com/p/763bfbd657b8",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://jishuin.proginn.com/p/763bfbd657b8"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"_2-typescript-你都用过哪些类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-typescript-你都用过哪些类型"}},[t._v("#")]),t._v(" 2.typescript 你都用过哪些类型")]),t._v(" "),v("h3",{attrs:{id:"_3-typescript-中-type-和-interface-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-typescript-中-type-和-interface-的区别"}},[t._v("#")]),t._v(" 3.typescript 中 type 和 interface 的区别")]),t._v(" "),v("p",[t._v("在 ts 中，定义类型由两种方式：接口（interface）和类型别名（type alias）")]),t._v(" "),v("p",[t._v("相同点：")]),t._v(" "),v("ol",[v("li",[t._v("都可以描述一个对象或者函数")])]),t._v(" "),v("p",[t._v("区别：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("interface 只能定义对象类型，type 声明的方式可以定义组合类型，交叉类型和原始类型")])]),t._v(" "),v("li",[v("p",[t._v("interface 方式可以实现接口的 extends/implements，而 type 不行")])]),t._v(" "),v("li",[v("p",[t._v("interface 可以声明合并，但是 type 不行")])])])])}),[],!1,null,null,null);p.default=_.exports}}]);