(window.webpackJsonp=window.webpackJsonp||[]).push([[464],{946:function(t,e,r){"use strict";r.r(e);var o=r(24),n=Object(o.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"cdn"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[t._v("#")]),t._v(" CDN")]),t._v(" "),r("p",[t._v("CDN 是 Content Delivery Network 的缩写，即“内容分发网络”")]),t._v(" "),r("p",[t._v('其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可 以就近取得所需的内容，解决 Internet 网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等 原因，解决用户访问网站的响应速度慢的根本原因。')]),t._v(" "),r("h3",{attrs:{id:"cdn-缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cdn-缓存"}},[t._v("#")]),t._v(" CDN 缓存")]),t._v(" "),r("ol",[r("li",[t._v("CDN 的缓存适用范围:")])]),t._v(" "),r("p",[t._v("CDN 对于常见的 HTTP 请求均是支持的，具体对不同请求方式的支持情况请参考表一。但是有一点需要注意的是虽然对这些类型的 HTTP 请求均是支持的，但是并不是对所有请求方式都会进行缓存的。 CDN 仅会对于 GET 请求进行缓存，而对于其他的请求均不进行缓存，仅是起到中间代理、转发的功能。（对于 http 协议里其他请求比如说 put 以及 POST 等动态回源的一些请求，CDN 可能就不会去做任何缓存的处理，而是直接透传给源站，然后由源站进行对应的处理后返回给客户端。）因此我们建议添加 CDN 的站点源站最好能够实现动静分离。将动态请求和静态请求的内容独立成两个站点，而 CDN 仅仅加速静态站点中的资源。")]),t._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[t._v("CDN 缓存什么内容")])]),t._v(" "),r("p",[t._v("缓存 html、图片、css、xml 等静态资源，不缓存含有？的动态地址、jsp、php，js 文件也不缓存【除非特殊设置】")]),t._v(" "),r("p",[t._v("缓存原站返回 HTTP 状态为 20*或 304，不缓存其他状态(例如 404，500，503)")]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[t._v("CDN 缓存内容的更新")])]),t._v(" "),r("p",[t._v("a）用户首次请求，CDN 从原站抓取后缓存，直到文件过期后有用户请求再次更新")]),t._v(" "),r("p",[t._v("b）程序主动通知 CDN 抓取")]),t._v(" "),r("ol",{attrs:{start:"4"}},[r("li",[t._v("CDN 返回 response 头解读")])]),t._v(" "),r("p",[t._v("我们在实际使用的过程中，我们又如何查看当前这个文件到底有没有在 CDN 节点上缓存或者它缓存的时间是多少呢？")]),t._v(" "),r("p",[t._v("资源在经过 CDN 节点以后，一定会在对应的 http 的 response 头里加若干的字段，如图即是常见的通过 CDN 访问的响应头，可以根据 X-Cache 查看当前该资源是否有在 CDN 的 L1 节点缓存，而查看 L2 节点的缓存情况则需要根据 Via 头中的第一部分查看，如果是 M 即是 MISS，表示对应的资源没有在对应的 CDN 节点上缓存；而出现 H 表示对应的资源有在 CDN 节点上缓。X-Swift-SaveTime 表示该资源缓存到 CDN 节点上的 GMT 时间（相比于北京时间晚 8 小时）；而 X-Swift-CacheTime 表示该资源在 CDN 节点上缓存多长时间会过期。")]),t._v(" "),r("p",[t._v("VIA 字段")]),t._v(" "),r("p",[t._v("VIA 字段，包含有四段信息，其中第一段和第三段会有一个 M 或者 H 的标识。第一段说明 L2 节点的缓存情况，第三段指的是 L1 节点的缓存情况，这两个其中有一个包含 H，就表示对应的资源已经在 CDN 节点上进行了缓存。那这一次访问就不需要再回到源站拉取对应的资源了。")]),t._v(" "),r("h3",{attrs:{id:"cdn-回源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cdn-回源"}},[t._v("#")]),t._v(" CDN 回源")]),t._v(" "),r("p",[t._v("回源：指的是 CDN 缓存服务器从源站获取所需要分发的资源。")]),t._v(" "),r("p",[t._v("CDN 缓存服务器一般是不会主动回源的，只有在缓存服务器缺少用户请求的资源时（可能是该资源 CDN 缓存服务器没有缓存，也可能是缓存过期），CDN 缓存服务器才会向源站发起请求，获取所需要分发的资源。")]),t._v(" "),r("p",[t._v("回源比: 其实回源比和缓存的命中率正好相反，回源比高，说明缓存系统的缓存命中率低。回源比分为回源请求数比例和回源流量比例两种。")]),t._v(" "),r("p",[t._v("回源请求数比例：收集所有边缘节点上的请求记录，没有缓存或缓存过期的请求以及不可缓存的请求均被作为回源请求，发往源站点服务器响应。其他的请求则由缓存系统直接使用缓存响应。其计算公式为：回源请求数/（回源请求数+用户发送的请求数）。")]),t._v(" "),r("p",[t._v("回源流量比：即用户所产生的流量当中，有多少流量是直接有源站点服务器响应的，其计算公式为：回源流量/（回源流量+用户请求访问的流量）")]),t._v(" "),r("hr"),t._v(" "),r("blockquote",[r("p",[t._v("参考：CDN 缓存（上）-CDN 初认识 "),r("a",{attrs:{href:"https://www.cnblogs.com/kunmomo/p/13067804.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/kunmomo/p/13067804.html"),r("OutboundLink")],1)])]),t._v(" "),r("blockquote",[r("p",[t._v("使用 CDN 缓存后的网站的访问过程 "),r("a",{attrs:{href:"https://www.cnblogs.com/kunmomo/p/13067833.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/kunmomo/p/13067833.html"),r("OutboundLink")],1)])]),t._v(" "),r("blockquote",[r("p",[t._v("CDN 缓存策略、CDN 缓存和浏览器缓存之间的关系、回源和回源比 "),r("a",{attrs:{href:"https://www.cnblogs.com/kunmomo/p/13067833.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/kunmomo/p/13067833.html"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);