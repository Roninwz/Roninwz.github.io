(window.webpackJsonp=window.webpackJsonp||[]).push([[478],{949:function(t,e,a){"use strict";a.r(e);var r=a(20),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"git-变基"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-变基"}},[t._v("#")]),t._v(" git 变基")]),t._v(" "),a("h3",{attrs:{id:"变基命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变基命令"}},[t._v("#")]),t._v(" 变基命令")]),t._v(" "),a("ol",[a("li",[t._v("终止 rebase 的操作 "),a("code",[t._v("git rebase --abort")])])]),t._v(" "),a("h3",{attrs:{id:"处理冲突的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理冲突的方式"}},[t._v("#")]),t._v(" 处理冲突的方式")]),t._v(" "),a("ol",[a("li",[t._v("（一股脑）")])]),t._v(" "),a("p",[t._v("使用 merge 命令合并分支，解决完冲突，执行 git add .和 git commit -m'fix conflict'。这个时候会产生一个 commit。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("（交互式）")])]),t._v(" "),a("p",[t._v("使用 rebase 命令合并分支，解决完冲突，执行 git add .和 git rebase --continue，不会产生额外的 commit。这样的好处是，‘干净’，分支上不会有无意义的解决分支的 commit；坏处，如果合并的分支中存在多个 commit，需要重复处理多次冲突。")]),t._v(" "),a("h3",{attrs:{id:"git-merge-和-rebase-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-和-rebase-的区别"}},[t._v("#")]),t._v(" git merge 和 rebase 的区别")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("rebase 操作不会生成新的节点，merge 操作会生成新的节点")])]),t._v(" "),a("li",[a("p",[t._v("rebase 会合并之前的 commit 历史，merge 命令不会保留 merge 的分支的 commit")])])]),t._v(" "),a("h3",{attrs:{id:"git-pull-和-git-pull-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-pull-和-git-pull-rebase"}},[t._v("#")]),t._v(" git pull 和 git pull --rebase")]),t._v(" "),a("p",[t._v("git pull 做了两个操作分别是‘获取’和合并。所以加了 rebase 就是以 rebase 的方式进行合并分支，默认为 merge。")])])}),[],!1,null,null,null);e.default=s.exports}}]);