(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{498:function(t,v,_){"use strict";_.r(v);var l=_(13),a=Object(l.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"分治算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治算法"}},[t._v("#")]),t._v(" 分治算法")]),t._v(" "),_("blockquote",[_("p",[t._v("参考："),_("a",{attrs:{href:"https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html"),_("OutboundLink")],1)])]),t._v(" "),_("ol",[_("li",[t._v("概念")])]),t._v(" "),_("p",[t._v("分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并")]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[t._v("基本思想和策略")]),t._v(" "),_("p",[t._v("分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。")]),t._v(" "),_("p",[t._v("分治策略是：对于一个规模为 n 的问题，若该问题可以容易地解决（比如说规模 n 较小）则直接解决，否则将其分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。")])])]),t._v(" "),_("h3",{attrs:{id:"分治算法步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治算法步骤"}},[t._v("#")]),t._v(" 分治算法步骤")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题")])]),t._v(" "),_("li",[_("p",[t._v("解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题")])]),t._v(" "),_("li",[_("p",[t._v("合并：将各个子问题的解合并为原问题的解")])])]),t._v(" "),_("h3",{attrs:{id:"分治法适用情况特征"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分治法适用情况特征"}},[t._v("#")]),t._v(" 分治法适用情况特征")]),t._v(" "),_("p",[t._v("分治法所能解决的问题一般具有以下几个特征：")]),t._v(" "),_("ol",[_("li",[t._v("该问题的规模缩小到一定的程度就可以容易地解决")])]),t._v(" "),_("blockquote",[_("p",[t._v("第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。")])]),t._v(" "),_("blockquote",[_("p",[t._v("第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("利用该问题分解出的子问题的解可以合并为该问题的解；")])]),t._v(" "),_("blockquote",[_("p",[t._v("第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。")])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。")])]),t._v(" "),_("blockquote",[_("p",[t._v("第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。")])]),t._v(" "),_("h3",{attrs:{id:"实例问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实例问题"}},[t._v("#")]),t._v(" 实例问题")]),t._v(" "),_("ul",[_("li",[t._v("二分搜索")]),t._v(" "),_("li",[t._v("大整数乘法")]),t._v(" "),_("li",[t._v("Strassen 矩阵乘法")]),t._v(" "),_("li",[t._v("棋盘覆盖")]),t._v(" "),_("li",[t._v("合并排序")]),t._v(" "),_("li",[t._v("快速排序")]),t._v(" "),_("li",[t._v("线性时间选择")]),t._v(" "),_("li",[t._v("最接近点对问题")]),t._v(" "),_("li",[t._v("循环赛日程表")]),t._v(" "),_("li",[t._v("汉诺塔")])])])}),[],!1,null,null,null);v.default=a.exports}}]);