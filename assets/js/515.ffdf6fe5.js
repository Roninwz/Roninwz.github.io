(window.webpackJsonp=window.webpackJsonp||[]).push([[515],{995:function(t,s,i){"use strict";i.r(s);var a=i(13),o=Object(a.a)({},(function(){var t=this,s=t.$createElement,i=t._self._c||s;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"吸顶解决方案"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#吸顶解决方案"}},[t._v("#")]),t._v(" 吸顶解决方案")]),t._v(" "),i("h3",{attrs:{id:"_1-position-sticky"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-position-sticky"}},[t._v("#")]),t._v(" 1. position: sticky")]),t._v(" "),i("h3",{attrs:{id:"_2-动态修改元素的-position"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-动态修改元素的-position"}},[t._v("#")]),t._v(" 2. 动态修改元素的 position")]),t._v(" "),i("p",[t._v("监听页面的滚动，比较 元素初始状态距离顶部的高度 offsetTop 与 页面此时的滚动高度 。当后者大于前者时，修改元素的 position 方式为 fixed。")]),t._v(" "),i("h2",{attrs:{id:"吸顶问题"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#吸顶问题"}},[t._v("#")]),t._v(" 吸顶问题")]),t._v(" "),i("h3",{attrs:{id:"_1-吸顶的那一刻伴随抖动"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_1-吸顶的那一刻伴随抖动"}},[t._v("#")]),t._v(" 1. 吸顶的那一刻伴随抖动")]),t._v(" "),i("p",[t._v("解决方案：为这个吸顶元素添加一个等高的父元素，我们监听这个父元素的 getBoundingClientRect().top 值来实现吸顶效果")]),t._v(" "),i("h3",{attrs:{id:"_2-吸顶效果不能及时响应"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-吸顶效果不能及时响应"}},[t._v("#")]),t._v(" 2. 吸顶效果不能及时响应")]),t._v(" "),i("p",[t._v("当页面往下滚动时，吸顶元素需要等页面滚动停止之后才会出现吸顶效果")]),t._v(" "),i("p",[t._v("当页面往上滚动时，滚动到吸顶元素恢复文档流位置时吸顶元素不恢复原样，而等页面停止滚动之后才会恢复原样")]),t._v(" "),i("p",[t._v("原因：")]),t._v(" "),i("p",[t._v("在 ios 系统上不能实时监听 scroll 滚动监听事件，在滚动停止时才触发其相关的事件。")]),t._v(" "),i("p",[t._v("解决方案：")]),t._v(" "),i("p",[t._v("还记得第一种方案中的 position:sticky 吗？这个属性在 IOS6 以上的系统中有良好的兼容性，所以我们可以区分 IOS 和 Android 设备做两种处理。")]),t._v(" "),i("p",[t._v("IOS 使用 position:sticky，Android 使用滚动监听 getBoundingClientRect().top 的值。")]),t._v(" "),i("p",[t._v("如果 IOS 版本过低呢？这里提供一种思路：window.requestAnimationFrame()。")])])}),[],!1,null,null,null);s.default=o.exports}}]);