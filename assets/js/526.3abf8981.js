(window.webpackJsonp=window.webpackJsonp||[]).push([[526],{1004:function(e,t,r){"use strict";r.r(t);var i=r(24),v=Object(i.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"git-常用术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-常用术语"}},[e._v("#")]),e._v(" git 常用术语")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("仓库（Repository）受版本控制的所有文件修订历史的共享数据库")])]),e._v(" "),r("li",[r("p",[e._v("工作空间（Workspace)本地硬盘或 Unix 用户帐户上编辑的文件副本")])]),e._v(" "),r("li",[r("p",[e._v("工作树/区（Working tree）工作区中包含了仓库的工作文件。您可以修改的内容和提交更改作为新的提交到仓库。")])]),e._v(" "),r("li",[r("p",[e._v("暂存区（Staging area）暂存区是工作区用来提交更改（commit）前可以暂存工作区的变化。")])]),e._v(" "),r("li",[r("p",[e._v("索引（Index）索引是暂存区的另一种术语。")])]),e._v(" "),r("li",[r("p",[e._v("签入（Checkin） 将新版本复制回仓库")])]),e._v(" "),r("li",[r("p",[e._v("签出（Checkout）从仓库中将文件的最新修订版本复制到工作空间")])]),e._v(" "),r("li",[r("p",[e._v("提交（Commit）对各自文件的工作副本做了更改，并将这些更改提交到仓库")])]),e._v(" "),r("li",[r("p",[e._v("冲突（Conflict）多人对同一文件的工作副本进行更改，并将这些更改提交到仓库")])]),e._v(" "),r("li",[r("p",[e._v("合并（Merge）将某分支上的更改联接到此主干或同为主干的另一个分支")])]),e._v(" "),r("li",[r("p",[e._v("分支（Branch）从主线上分离开的副本，默认分支叫 master")])]),e._v(" "),r("li",[r("p",[e._v("锁（Lock）获得修改文件的专有权限。")])]),e._v(" "),r("li",[r("p",[e._v("头（HEAD）头是一个象征性的参考，最常用以指向当前选择的分支。")])]),e._v(" "),r("li",[r("p",[e._v("修订（Revision）表示代码的一个版本状态。Git 通过用 SHA1 hash 算法表示的 ID 来标识不同的版本。")])]),e._v(" "),r("li",[r("p",[e._v("标记（Tags）标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态。")])])]),e._v(" "),r("h2",{attrs:{id:"git-对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-对比"}},[e._v("#")]),e._v(" git 对比")]),e._v(" "),r("h3",{attrs:{id:"git-revert-和-reset-区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-revert-和-reset-区别"}},[e._v("#")]),e._v(" git revert 和 reset 区别")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的 commit")])]),e._v(" "),r("li",[r("p",[e._v("git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。")])])]),e._v(" "),r("h3",{attrs:{id:"git-merge-和-rebase-区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-和-rebase-区别"}},[e._v("#")]),e._v(" git merge 和 rebase 区别")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("rebase 操作不会生成新的节点，merge 操作会生成新的节点")])]),e._v(" "),r("li",[r("p",[e._v("rebase 会合并之前的 commit 历史，merge 命令不会保留 merge 的分支的 commit")])])]),e._v(" "),r("ul",[r("li",[e._v("应用场景：")])]),e._v(" "),r("blockquote",[r("p",[e._v("如果项目庞大，需要一个简洁的线性历史树便于 leader 管理，推荐使用 git rebase 。")])]),e._v(" "),r("blockquote",[r("p",[e._v("如果是小型项目，需要审查历史纪录来便于编写过程报告，则推荐使用 git merge 。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);