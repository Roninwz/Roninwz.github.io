(window.webpackJsonp=window.webpackJsonp||[]).push([[538],{1092:function(_,v,o){"use strict";o.r(v);var s=o(14),e=Object(s.a)({},(function(){var _=this,v=_.$createElement,o=_._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[o("h2",{attrs:{id:"单点登录"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#单点登录"}},[_._v("#")]),_._v(" 单点登录")]),_._v(" "),o("p",[_._v("单点登录（Single Sign On），简称为 SSO：是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。")]),_._v(" "),o("p",[_._v("SSO 核心意义就一句话："),o("strong",[o("em",[_._v("一处登录，处处登录；一处注销，处处注销")])])]),_._v(" "),o("p",[_._v("单点登录的关键在于，如何让 Session Id（或 Token）在多个域中共享:")]),_._v(" "),o("blockquote",[o("p",[_._v("一般情况下，用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，但是由于不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 SessionId 是往往保存在浏览器 Cookie 中的，因此存在作用域的限制，无法跨域名传递，也就是说当用户在 a.com 中登录后，Session Id 仅在浏览器访问 a.com 时才会自动在请求头中携带，而当浏览器访问 b.com 时，Session Id 是不会被带过去的。实现单点登录的关键在于，如何让 Session Id（或 Token）在多个域中共享。")])]),_._v(" "),o("h3",{attrs:{id:"单点登录优缺点"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#单点登录优缺点"}},[_._v("#")]),_._v(" 单点登录优缺点")]),_._v(" "),o("p",[_._v("优点：")]),_._v(" "),o("ol",[o("li",[_._v("提高用户的效率。")])]),_._v(" "),o("p",[_._v("用户不再被多次登录困扰，也不需要记住多个 ID 和密码。另外，用户忘记密码并求助于支持人员的情况也会减少。")]),_._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[_._v("提高开发人员的效率。")])]),_._v(" "),o("p",[_._v("SSO 为开发人员提供了一个通用的身份验证框架。实际上，如果 SSO 机制是独立的，那么开发人员就完全不需要为身份验证操心。他们可以假设，只要对应用程序的请求附带一个用户名，身份验证就已经完成了。")]),_._v(" "),o("ol",{attrs:{start:"3"}},[o("li",[_._v("简化管理。")])]),_._v(" "),o("p",[_._v("如果应用程序加入了单点登录协议，管理用户帐号的负担就会减轻。简化的程度取决于应用程序，因为 SSO 只处理身份验证。所以，应用程序可能仍然需要设置用户的属性（比如访问特权）。")]),_._v(" "),o("p",[_._v("缺点：")]),_._v(" "),o("ol",[o("li",[_._v("不利于重构")])]),_._v(" "),o("p",[_._v("因为涉及到的系统很多，要重构必须要兼容所有的系统，可能很耗时。")]),_._v(" "),o("ol",{attrs:{start:"2"}},[o("li",[_._v("无人看守桌面")])]),_._v(" "),o("p",[_._v("因为只需要登录一次，所有的授权的应用系统都可以访问，可能导致一些很重要的信息泄露。")]),_._v(" "),o("h2",{attrs:{id:"单点登录解决方案"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#单点登录解决方案"}},[_._v("#")]),_._v(" 单点登录解决方案")]),_._v(" "),o("h3",{attrs:{id:"父域-cookie-同域"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#父域-cookie-同域"}},[_._v("#")]),_._v(" 父域 Cookie（同域）")]),_._v(" "),o("p",[_._v("这是最简单的单点登录实现方式，是使用 cookie 作为媒介，存放用户凭证。 用户登录父应用之后，应用返回一个加密的 cookie，当用户访问子应用的时候，携带上这个 cookie，授权应用解密 cookie 并进行校验，校验通过则登录当前用户。")]),_._v(" "),o("p",[_._v("缺点：")]),_._v(" "),o("ol",[o("li",[o("p",[_._v("Cookie 不安全")])]),_._v(" "),o("li",[o("p",[_._v("不能跨域实现免登")])])]),_._v(" "),o("h3",{attrs:{id:"认证中心-不同域"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#认证中心-不同域"}},[_._v("#")]),_._v(" 认证中心（不同域）")]),_._v(" "),o("p",[_._v("我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。")]),_._v(" "),o("p",[_._v("用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）")]),_._v(" "),o("p",[_._v("应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。")]),_._v(" "),o("p",[_._v("应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。")]),_._v(" "),o("p",[_._v("登录流程：")]),_._v(" "),o("ol",[o("li",[o("p",[_._v("用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心发现用户未登录，将用户引导至登录页面")])]),_._v(" "),o("li",[o("p",[_._v("用户输入用户名密码提交登录申请")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心带着令牌跳转会最初的请求地址（系统 1）")])]),_._v(" "),o("li",[o("p",[_._v("系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心校验令牌，返回有效，注册系统 1")])]),_._v(" "),o("li",[o("p",[_._v("系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源")])]),_._v(" "),o("li",[o("p",[_._v("用户访问系统 2 的受保护资源，系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌")])]),_._v(" "),o("li",[o("p",[_._v("系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心校验令牌，返回有效，注册系统 2")])]),_._v(" "),o("li",[o("p",[_._v("系统 2 使用该令牌创建与用户的局部会话，返回受保护资源")])])]),_._v(" "),o("p",[_._v("用户登录成功之后，会与 sso 认证中心及各个子系统建立会话，用户与 sso 认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过 sso 认证中心，全局会话与局部会话有如下约束关系")]),_._v(" "),o("ol",[o("li",[o("p",[_._v("局部会话存在，全局会话一定存在")])]),_._v(" "),o("li",[o("p",[_._v("全局会话存在，局部会话不一定存在")])]),_._v(" "),o("li",[o("p",[_._v("全局会话销毁，局部会话必须销毁")])])]),_._v(" "),o("p",[_._v("单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，sso 认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作")]),_._v(" "),o("p",[_._v("注销流程：")]),_._v(" "),o("ol",[o("li",[o("p",[_._v("用户向系统 1 发起注销请求")])]),_._v(" "),o("li",[o("p",[_._v("系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 sso 认证中心发起注销请求")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心向所有注册系统发起注销请求")])]),_._v(" "),o("li",[o("p",[_._v("各注册系统接收 sso 认证中心的注销请求，销毁局部会话")])]),_._v(" "),o("li",[o("p",[_._v("sso 认证中心引导用户至登录页面")])])]),_._v(" "),o("hr"),_._v(" "),o("p",[_._v("参考："),o("a",{attrs:{href:"https://www.zhihu.com/question/342103776",target:"_blank",rel:"noopener noreferrer"}},[_._v("现在用的比较多的单点登录技术是什么？"),o("OutboundLink")],1)]),_._v(" "),o("p",[o("a",{attrs:{href:"https://juejin.cn/post/6933115003327217671",target:"_blank",rel:"noopener noreferrer"}},[_._v("前端常见登录实现方案 + 单点登录方案"),o("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=e.exports}}]);