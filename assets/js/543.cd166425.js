(window.webpackJsonp=window.webpackJsonp||[]).push([[543],{1104:function(v,_,t){"use strict";t.r(_);var a=t(14),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"前端-vue-权限管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端-vue-权限管理"}},[v._v("#")]),v._v(" 前端 vue 权限管理")]),v._v(" "),t("p",[v._v("权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源")]),v._v(" "),t("p",[v._v("而前端权限归根结底是请求的发起权，请求的发起可能有下面两种形式触发")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("页面加载触发")])]),v._v(" "),t("li",[t("p",[v._v("页面上的按钮点击触发")])])]),v._v(" "),t("p",[v._v("总的来说，所有的请求发起都触发自前端路由或视图")]),v._v(" "),t("p",[v._v("所以我们可以从这两方面入手，对触发权限的源头进行控制，最终要实现的目标是：")]),v._v(" "),t("p",[v._v("路由方面，用户登录后只能看到自己有权访问的导航菜单，也只能访问自己有权访问的路由地址，否则将跳转 4xx 提示页")]),v._v(" "),t("p",[v._v("视图方面，用户只能看到自己有权浏览的内容和有权操作的控件")]),v._v(" "),t("p",[v._v("最后再加上请求控制作为最后一道防线，路由可能配置失误，按钮可能忘了加权限，这种时候请求控制可以用来兜底，越权请求将在前端被拦截")]),v._v(" "),t("p",[v._v("前端权限控制可以分为四个方面：")]),v._v(" "),t("ol",[t("li",[v._v("接口权限")]),v._v(" "),t("li",[v._v("菜单权限")]),v._v(" "),t("li",[v._v("路由权限")]),v._v(" "),t("li",[v._v("按钮权限")])]),v._v(" "),t("h3",{attrs:{id:"接口权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口权限"}},[v._v("#")]),v._v(" 接口权限")]),v._v(" "),t("p",[v._v("接口权限目前一般采用 jwt 的形式来验证，没有通过的话一般返回 401，跳转到登录页面重新进行登录")]),v._v(" "),t("p",[v._v("登录完拿到 token，将 token 存起来，通过 axios 请求拦截器进行拦截，每次请求的时候头部携带 token")]),v._v(" "),t("h3",{attrs:{id:"菜单权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#菜单权限"}},[v._v("#")]),v._v(" 菜单权限")]),v._v(" "),t("p",[v._v("方案 1：菜单与路由分离，菜单由后端返回，路由由前端写死")]),v._v(" "),t("p",[v._v("每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的 name 与路由的 name 是一一对应的，而后端返回的菜单就已经是经过权限过滤的")]),v._v(" "),t("p",[v._v("如果根据路由 name 找不到对应的菜单，就表示用户有没权限访问")]),v._v(" "),t("p",[v._v("如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过 addRoutes 动态挂载")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用")])]),v._v(" "),t("li",[t("p",[v._v("全局路由守卫里，每次路由跳转都要做判断")])])]),v._v(" "),t("p",[v._v("方案 2：菜单和路由都由后端返回")]),v._v(" "),t("p",[v._v("在将后端返回路由通过 addRoutes 动态挂载之间，需要将数据处理一下，将 component 字段换为真正的组件")]),v._v(" "),t("p",[v._v("如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段，前端拿到数据也要做相应的处理")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("全局路由守卫里，每次路由跳转都要做判断")])]),v._v(" "),t("li",[t("p",[v._v("前后端的配合要求更高")])])]),v._v(" "),t("h3",{attrs:{id:"路由权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由权限"}},[v._v("#")]),v._v(" 路由权限")]),v._v(" "),t("p",[v._v("初始化的时候先挂载不需要权限控制的路由，比如登录页，404 等错误页。如果用户通过 URL 进行强制访问，则会直接进入 404，相当于从源头上做了控制")]),v._v(" "),t("p",[v._v("登录后，获取用户的权限信息，然后筛选有权限访问的路由，在全局路由守卫里进行调用 addRoutes 添加路由")]),v._v(" "),t("p",[v._v("按需挂载，路由就需要知道用户的路由权限，也就是在用户登录进来的时候就要知道当前用户拥有哪些路由权限")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("全局路由守卫里，每次路由跳转都要做判断")])]),v._v(" "),t("li",[t("p",[v._v("菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译")])]),v._v(" "),t("li",[t("p",[v._v("菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识")])])]),v._v(" "),t("h3",{attrs:{id:"按钮权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按钮权限"}},[v._v("#")]),v._v(" 按钮权限")]),v._v(" "),t("p",[v._v("自定义指令进行按钮权限的判断：通过 store 里面取当前用户角色权限来对比指令中传入的角色权限，是否有权限，没有权限移除按钮 dom")]),v._v(" "),t("hr"),v._v(" "),t("p",[v._v("参考："),t("a",{attrs:{href:"https://www.cnblogs.com/houxianzhou/p/14270260.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Vue 权限管理该怎么做？控制到按钮级别的权限怎么做？"),t("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=e.exports}}]);