(window.webpackJsonp=window.webpackJsonp||[]).push([[546],{1035:function(t,e,i){"use strict";i.r(e);var v=i(24),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"git-常用术语"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-常用术语"}},[t._v("#")]),t._v(" git 常用术语")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("仓库（Repository）受版本控制的所有文件修订历史的共享数据库")])]),t._v(" "),i("li",[i("p",[t._v("工作空间（Workspace)本地硬盘或 Unix 用户帐户上编辑的文件副本")])]),t._v(" "),i("li",[i("p",[t._v("工作树/区（Working tree）工作区中包含了仓库的工作文件。您可以修改的内容和提交更改作为新的提交到仓库。")])]),t._v(" "),i("li",[i("p",[t._v("暂存区（Staging area）暂存区是工作区用来提交更改（commit）前可以暂存工作区的变化。")])]),t._v(" "),i("li",[i("p",[t._v("索引（Index）索引是暂存区的另一种术语。")])]),t._v(" "),i("li",[i("p",[t._v("签入（Checkin） 将新版本复制回仓库")])]),t._v(" "),i("li",[i("p",[t._v("签出（Checkout）从仓库中将文件的最新修订版本复制到工作空间")])]),t._v(" "),i("li",[i("p",[t._v("提交（Commit）对各自文件的工作副本做了更改，并将这些更改提交到仓库")])]),t._v(" "),i("li",[i("p",[t._v("冲突（Conflict）多人对同一文件的工作副本进行更改，并将这些更改提交到仓库")])]),t._v(" "),i("li",[i("p",[t._v("合并（Merge）将某分支上的更改联接到此主干或同为主干的另一个分支")])]),t._v(" "),i("li",[i("p",[t._v("分支（Branch）从主线上分离开的副本，默认分支叫 master")])]),t._v(" "),i("li",[i("p",[t._v("锁（Lock）获得修改文件的专有权限。")])]),t._v(" "),i("li",[i("p",[t._v("头（HEAD）头是一个象征性的参考，最常用以指向当前选择的分支。")])]),t._v(" "),i("li",[i("p",[t._v("修订（Revision）表示代码的一个版本状态。Git 通过用 SHA1 hash 算法表示的 ID 来标识不同的版本。")])]),t._v(" "),i("li",[i("p",[t._v("标记（Tags）标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态。")])])]),t._v(" "),i("h2",{attrs:{id:"git-对比"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-对比"}},[t._v("#")]),t._v(" git 对比")]),t._v(" "),i("h3",{attrs:{id:"git-与-svn-区别"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-与-svn-区别"}},[t._v("#")]),t._v(" Git 与 SVN 区别")]),t._v(" "),i("ol",[i("li",[t._v("Git 是分布式的，SVN 是集中式的")])]),t._v(" "),i("p",[t._v("集中式版本控制系统：版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。​ 集中式版本控制系统最大的毛病就是必须联网才能工作。")]),t._v(" "),i("p",[t._v("​ 分布式版本控制系统：分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。")]),t._v(" "),i("ol",{attrs:{start:"2"}},[i("li",[i("p",[t._v("GIT 把内容按元数据方式存储，而 SVN 是按文件：因为 git 目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。​")])]),t._v(" "),i("li",[i("p",[t._v("GIT 分支和 SVN 的分支不同：svn 会发生分支遗漏的情况，而 git 可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件。")])]),t._v(" "),i("li",[i("p",[t._v("GIT 的内容完整性要优于 SVN：GIT 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。")])])]),t._v(" "),i("h3",{attrs:{id:"git-revert-和-reset-区别"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-revert-和-reset-区别"}},[t._v("#")]),t._v(" git revert 和 reset 区别")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的 commit")])]),t._v(" "),i("li",[i("p",[t._v("git reset 是把 HEAD 向后移动了一下，而 git revert 是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。")])])]),t._v(" "),i("h3",{attrs:{id:"git-merge-和-rebase-区别"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-和-rebase-区别"}},[t._v("#")]),t._v(" git merge 和 rebase 区别")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("rebase 操作不会生成新的节点，merge 操作会生成新的节点")])]),t._v(" "),i("li",[i("p",[t._v("rebase 会合并之前的 commit 历史，merge 命令不会保留 merge 的分支的 commit")])])]),t._v(" "),i("ul",[i("li",[t._v("应用场景：")])]),t._v(" "),i("blockquote",[i("p",[t._v("如果项目庞大，需要一个简洁的线性历史树便于 leader 管理，推荐使用 git rebase 。")])]),t._v(" "),i("blockquote",[i("p",[t._v("如果是小型项目，需要审查历史纪录来便于编写过程报告，则推荐使用 git merge 。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);