(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{574:function(t,_,v){"use strict";v.r(_);var l=v(14),i=Object(l.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"算法基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#算法基础"}},[t._v("#")]),t._v(" 算法基础")]),t._v(" "),v("h3",{attrs:{id:"_1-时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-时间复杂度"}},[t._v("#")]),t._v(" 1.时间复杂度")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("最好情况时间复杂度：代码在最理想情况下执行的时间复杂度。")])]),t._v(" "),v("li",[v("p",[t._v("最坏情况时间复杂度：代码在最坏情况下执行的时间复杂度。")])]),t._v(" "),v("li",[v("p",[t._v("平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。")])]),t._v(" "),v("li",[v("p",[t._v("均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。")])])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("求解算法的时间复杂度的具体步骤")]),t._v(" "),v("ul",[v("li",[t._v("⑴ 找出算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。")]),t._v(" "),v("li",[t._v("⑵ 计算基本语句的执行次数的数量级；")]),t._v(" "),v("li",[t._v("⑶ 用大 Ο 记号表示算法的时间性能。")])])]),t._v(" "),v("li",[v("p",[t._v("分析一段代码的时间复杂度的三个方法")]),t._v(" "),v("ul",[v("li",[t._v("只关注循环执行次数最多的的一段代码")]),t._v(" "),v("li",[t._v("加法法则：总复杂度等于量级最大的那段代码的复杂度")]),t._v(" "),v("li",[t._v("乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积")])])])])])}),[],!1,null,null,null);_.default=i.exports}}]);