(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{524:function(t,v,_){"use strict";_.r(v);var e=_(24),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"堆概览"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆概览"}},[t._v("#")]),t._v(" 堆概览")]),t._v(" "),_("h3",{attrs:{id:"堆和栈有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈有什么区别"}},[t._v("#")]),t._v(" 堆和栈有什么区别")]),t._v(" "),_("p",[t._v("栈：先进后出；由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。")]),t._v(" "),_("p",[t._v("堆：队列优先,先进先出；动态分配的空间 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式类似于链表。")]),t._v(" "),_("p",[t._v("堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：")]),t._v(" "),_("p",[t._v("（1）"),_("strong",[_("em",[t._v("管理方式不同")])]),t._v("。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；")]),t._v(" "),_("p",[t._v("（2）"),_("strong",[_("em",[t._v("空间大小不同")])]),t._v("。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；")]),t._v(" "),_("p",[t._v("（3）"),_("strong",[_("em",[t._v("生长方向不同")])]),t._v("。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。")]),t._v(" "),_("p",[t._v("（4）"),_("strong",[_("em",[t._v("分配方式不同")])]),t._v("。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。")]),t._v(" "),_("p",[t._v("（5）"),_("strong",[_("em",[t._v("分配效率不同")])]),t._v("。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由 C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。")]),t._v(" "),_("p",[t._v("（6）"),_("strong",[_("em",[t._v("存放内容不同")])]),t._v("。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者 BSS 段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。")]),t._v(" "),_("p",[t._v("从以上可以看到，堆和栈相比，由于大量 malloc()/free()或 new/delete 的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。")]),t._v(" "),_("p",[t._v("无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。")])])}),[],!1,null,null,null);v.default=s.exports}}]);